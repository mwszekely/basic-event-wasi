import { parseArray } from "../_private/iovec.js";
import { writeUint32 } from "../util/write-uint32.js";
import { writeUint8 } from "../util/write-uint8.js";
export class FileDescriptorReadEvent extends CustomEvent {
    _bytesWritten = 0;
    constructor(impl, fileDescriptor, requestedBufferInfo) {
        super("fd_read", {
            bubbles: false,
            cancelable: true,
            detail: {
                fileDescriptor,
                requestedBuffers: requestedBufferInfo,
                readIntoMemory: (inputBuffers) => {
                    // 100% untested, probably doesn't work if I'm being honest
                    for (let i = 0; i < requestedBufferInfo.length; ++i) {
                        if (i >= inputBuffers.length)
                            break;
                        const buffer = inputBuffers[i];
                        for (let j = 0; j < Math.min(buffer.byteLength, inputBuffers[j].byteLength); ++j) {
                            writeUint8(impl, requestedBufferInfo[i].bufferStart + j, buffer[j]);
                            ++this._bytesWritten;
                        }
                    }
                }
            }
        });
    }
    bytesWritten() {
        return this._bytesWritten;
    }
}
export class UnhandledFileReadEvent extends Error {
    constructor(fd) {
        super(`Unhandled read to file descriptor #${fd}.`);
    }
}
/** POSIX readv */
export function fd_read(fd, iov, iovcnt, pnum) {
    let nWritten = 0;
    const gen = parseArray(this, iov, iovcnt);
    // Get all the data to read in its separate buffers
    //const asTypedArrays = [...gen].map(({ bufferStart, bufferLength }) => { nWritten += bufferLength; return new Uint8Array(this.getMemory().buffer, bufferStart, bufferLength) });
    const event = new FileDescriptorReadEvent(this, fd, [...gen]);
    if (this.dispatchEvent(event)) {
        nWritten = 0;
        /*if (fd == 0) {

        }
        else
            return errorno.badf;*/
    }
    else {
        nWritten = event.bytesWritten();
    }
    writeUint32(this, pnum, nWritten);
    return 0;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmRfcmVhZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93YXNpX3NuYXBzaG90X3ByZXZpZXcxL2ZkX3JlYWQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFjLFVBQVUsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBRTlELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUN0RCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFpQnBELE1BQU0sT0FBTyx1QkFBd0IsU0FBUSxXQUEwQztJQUMzRSxhQUFhLEdBQUcsQ0FBQyxDQUFDO0lBRTFCLFlBQVksSUFBc0IsRUFBRSxjQUFzQixFQUFFLG1CQUE0QjtRQUNwRixLQUFLLENBQUMsU0FBUyxFQUFFO1lBQ2IsT0FBTyxFQUFFLEtBQUs7WUFDZCxVQUFVLEVBQUUsSUFBSTtZQUNoQixNQUFNLEVBQUU7Z0JBQ0osY0FBYztnQkFDZCxnQkFBZ0IsRUFBRSxtQkFBbUI7Z0JBQ3JDLGNBQWMsRUFBRSxDQUFDLFlBQVksRUFBRSxFQUFFO29CQUM3QiwyREFBMkQ7b0JBQzNELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxtQkFBbUIsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQzt3QkFDbEQsSUFBSSxDQUFDLElBQUksWUFBWSxDQUFDLE1BQU07NEJBQ3hCLE1BQU07d0JBQ1YsTUFBTSxNQUFNLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUMvQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsVUFBVSxFQUFFLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDOzRCQUMvRSxVQUFVLENBQUMsSUFBSSxFQUFFLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsR0FBRyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7NEJBQ3BFLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQzt3QkFDekIsQ0FBQztvQkFDTCxDQUFDO2dCQUNMLENBQUM7YUFDSjtTQUNKLENBQUMsQ0FBQztJQUNQLENBQUM7SUFDRCxZQUFZO1FBQ1IsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDO0lBQzlCLENBQUM7Q0FDSjtBQUVELE1BQU0sT0FBTyxzQkFBdUIsU0FBUSxLQUFLO0lBQzdDLFlBQVksRUFBVTtRQUNsQixLQUFLLENBQUMsc0NBQXNDLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDdkQsQ0FBQztDQUNKO0FBR0Qsa0JBQWtCO0FBQ2xCLE1BQU0sVUFBVSxPQUFPLENBQXlCLEVBQWtCLEVBQUUsR0FBVyxFQUFFLE1BQWMsRUFBRSxJQUFZO0lBRXpHLElBQUksUUFBUSxHQUFHLENBQUMsQ0FBQztJQUNqQixNQUFNLEdBQUcsR0FBRyxVQUFVLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUUxQyxtREFBbUQ7SUFDbkQsaUxBQWlMO0lBRWpMLE1BQU0sS0FBSyxHQUFHLElBQUksdUJBQXVCLENBQUMsSUFBSSxFQUFFLEVBQUUsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUM5RCxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQztRQUM1QixRQUFRLEdBQUcsQ0FBQyxDQUFDO1FBQ2I7Ozs7a0NBSTBCO0lBQzlCLENBQUM7U0FDSSxDQUFDO1FBQ0YsUUFBUSxHQUFHLEtBQUssQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUNwQyxDQUFDO0lBRUQsV0FBVyxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFFbEMsT0FBTyxDQUFDLENBQUM7QUFDYixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdHlwZSBJb3ZlYywgcGFyc2VBcnJheSB9IGZyb20gXCIuLi9fcHJpdmF0ZS9pb3ZlYy5qc1wiO1xyXG5pbXBvcnQgdHlwZSB7IEZpbGVEZXNjcmlwdG9yIH0gZnJvbSBcIi4uL3R5cGVzLmpzXCI7XHJcbmltcG9ydCB7IHdyaXRlVWludDMyIH0gZnJvbSBcIi4uL3V0aWwvd3JpdGUtdWludDMyLmpzXCI7XHJcbmltcG9ydCB7IHdyaXRlVWludDggfSBmcm9tIFwiLi4vdXRpbC93cml0ZS11aW50OC5qc1wiO1xyXG5pbXBvcnQgdHlwZSB7IEluc3RhbnRpYXRlZFdhc20gfSBmcm9tIFwiLi4vd2FzbS5qc1wiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBGaWxlRGVzY3JpcHRvclJlYWRFdmVudERldGFpbCB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBbZmlsZSBkZXNjcmlwdG9yXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaWxlX2Rlc2NyaXB0b3IpLCBhIDAtaW5kZXhlZCBudW1iZXIgZGVzY3JpYmluZyB3aGVyZSB0aGUgZGF0YSBpcyBnb2luZyB0by9jb21pbmcgZnJvbS5cclxuICAgICAqIFxyXG4gICAgICogSXQncyBtb3JlLW9yLWxlc3MgW3VuaXZlcnNhbGx5IGV4cGVjdGVkXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdGFuZGFyZF9zdHJlYW0pIHRoYXQgMCBpcyBmb3IgaW5wdXQsIDEgZm9yIG91dHB1dCwgYW5kIDIgZm9yIGVycm9ycyxcclxuICAgICAqIHNvIHlvdSBjYW4gbWFwIDEgdG8gYGNvbnNvbGUubG9nYCBhbmQgMiB0byBgY29uc29sZS5lcnJvcmAsIHdpdGggb3RoZXJzIGhhbmRsZWQgd2l0aCB0aGUgdmFyaW91cyBmaWxlLW9wZW5pbmcgY2FsbHMuIFxyXG4gICAgICovXHJcbiAgICBmaWxlRGVzY3JpcHRvcjogbnVtYmVyO1xyXG5cclxuICAgIHJlcXVlc3RlZEJ1ZmZlcnM6IElvdmVjW107XHJcblxyXG4gICAgcmVhZEludG9NZW1vcnkoYnVmZmVyczogKFVpbnQ4QXJyYXkpW10pOiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgRmlsZURlc2NyaXB0b3JSZWFkRXZlbnQgZXh0ZW5kcyBDdXN0b21FdmVudDxGaWxlRGVzY3JpcHRvclJlYWRFdmVudERldGFpbD4ge1xyXG4gICAgcHJpdmF0ZSBfYnl0ZXNXcml0dGVuID0gMDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihpbXBsOiBJbnN0YW50aWF0ZWRXYXNtLCBmaWxlRGVzY3JpcHRvcjogbnVtYmVyLCByZXF1ZXN0ZWRCdWZmZXJJbmZvOiBJb3ZlY1tdKSB7XHJcbiAgICAgICAgc3VwZXIoXCJmZF9yZWFkXCIsIHtcclxuICAgICAgICAgICAgYnViYmxlczogZmFsc2UsXHJcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGRldGFpbDoge1xyXG4gICAgICAgICAgICAgICAgZmlsZURlc2NyaXB0b3IsXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0ZWRCdWZmZXJzOiByZXF1ZXN0ZWRCdWZmZXJJbmZvLFxyXG4gICAgICAgICAgICAgICAgcmVhZEludG9NZW1vcnk6IChpbnB1dEJ1ZmZlcnMpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAxMDAlIHVudGVzdGVkLCBwcm9iYWJseSBkb2Vzbid0IHdvcmsgaWYgSSdtIGJlaW5nIGhvbmVzdFxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxdWVzdGVkQnVmZmVySW5mby5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA+PSBpbnB1dEJ1ZmZlcnMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGlucHV0QnVmZmVyc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBNYXRoLm1pbihidWZmZXIuYnl0ZUxlbmd0aCwgaW5wdXRCdWZmZXJzW2pdLmJ5dGVMZW5ndGgpOyArK2opIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlVWludDgoaW1wbCwgcmVxdWVzdGVkQnVmZmVySW5mb1tpXS5idWZmZXJTdGFydCArIGosIGJ1ZmZlcltqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK3RoaXMuX2J5dGVzV3JpdHRlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYnl0ZXNXcml0dGVuKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J5dGVzV3JpdHRlbjtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFVuaGFuZGxlZEZpbGVSZWFkRXZlbnQgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihmZDogbnVtYmVyKSB7XHJcbiAgICAgICAgc3VwZXIoYFVuaGFuZGxlZCByZWFkIHRvIGZpbGUgZGVzY3JpcHRvciAjJHtmZH0uYCk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG4vKiogUE9TSVggcmVhZHYgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZkX3JlYWQodGhpczogSW5zdGFudGlhdGVkV2FzbSwgZmQ6IEZpbGVEZXNjcmlwdG9yLCBpb3Y6IG51bWJlciwgaW92Y250OiBudW1iZXIsIHBudW06IG51bWJlcikge1xyXG5cclxuICAgIGxldCBuV3JpdHRlbiA9IDA7XHJcbiAgICBjb25zdCBnZW4gPSBwYXJzZUFycmF5KHRoaXMsIGlvdiwgaW92Y250KTtcclxuXHJcbiAgICAvLyBHZXQgYWxsIHRoZSBkYXRhIHRvIHJlYWQgaW4gaXRzIHNlcGFyYXRlIGJ1ZmZlcnNcclxuICAgIC8vY29uc3QgYXNUeXBlZEFycmF5cyA9IFsuLi5nZW5dLm1hcCgoeyBidWZmZXJTdGFydCwgYnVmZmVyTGVuZ3RoIH0pID0+IHsgbldyaXR0ZW4gKz0gYnVmZmVyTGVuZ3RoOyByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy5nZXRNZW1vcnkoKS5idWZmZXIsIGJ1ZmZlclN0YXJ0LCBidWZmZXJMZW5ndGgpIH0pO1xyXG5cclxuICAgIGNvbnN0IGV2ZW50ID0gbmV3IEZpbGVEZXNjcmlwdG9yUmVhZEV2ZW50KHRoaXMsIGZkLCBbLi4uZ2VuXSk7XHJcbiAgICBpZiAodGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KSkge1xyXG4gICAgICAgIG5Xcml0dGVuID0gMDtcclxuICAgICAgICAvKmlmIChmZCA9PSAwKSB7XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiBlcnJvcm5vLmJhZGY7Ki9cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG5Xcml0dGVuID0gZXZlbnQuYnl0ZXNXcml0dGVuKCk7XHJcbiAgICB9XHJcblxyXG4gICAgd3JpdGVVaW50MzIodGhpcywgcG51bSwgbldyaXR0ZW4pO1xyXG5cclxuICAgIHJldHVybiAwO1xyXG59XHJcbiJdfQ==