import { InstantiatedWasm } from "../../wasm.js";
import { readLatin1String } from "../string.js";
/**
 * Registering a type is an async function called by a sync function. This handles the conversion, adding the promise to `AllEmbindPromises`.
 *
 * Also, because every single registration comes with a name that needs to be parsed, this also parses that name for you.
 */
export function _embind_register(impl, namePtr, func) {
    _embind_register_known_name(impl, readLatin1String(impl, namePtr), func);
}
/**
 * Same as `_embind_register`, but for known (or synthetic) names.
 */
export function _embind_register_known_name(impl, name, func) {
    const promise = (async () => {
        let handle = 0;
        // Fun fact: setTimeout doesn't exist in Worklets! 
        // I guess it vaguely makes sense in a "determinism is good" way, 
        // but it also seems generally useful there?
        if (typeof setTimeout === 'function')
            handle = setTimeout(() => { console.warn(`The function "${name}" uses an unsupported argument or return type, as its dependencies are not resolving. It's unlikely the embind promise will resolve.`); }, 1000);
        await func(name);
        if (handle)
            clearTimeout(handle);
    })();
    AllEmbindPromises.push(promise);
}
export async function awaitAllEmbind() {
    await Promise.all(AllEmbindPromises);
}
const AllEmbindPromises = new Array();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVnaXN0ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvX3ByaXZhdGUvZW1iaW5kL3JlZ2lzdGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNqRCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFFaEQ7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxnQkFBZ0IsQ0FBQyxJQUFzQixFQUFFLE9BQWUsRUFBRSxJQUE4QztJQUNwSCwyQkFBMkIsQ0FBQyxJQUFJLEVBQUUsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQzdFLENBQUM7QUFFRDs7R0FFRztBQUNILE1BQU0sVUFBVSwyQkFBMkIsQ0FBQyxJQUFzQixFQUFFLElBQVksRUFBRSxJQUE4QztJQUU1SCxNQUFNLE9BQU8sR0FBa0IsQ0FBQyxLQUFLLElBQUksRUFBRTtRQUN2QyxJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUM7UUFDZixtREFBbUQ7UUFDbkQsa0VBQWtFO1FBQ2xFLDRDQUE0QztRQUM1QyxJQUFJLE9BQU8sVUFBVSxLQUFLLFVBQVU7WUFDaEMsTUFBTSxHQUFHLFVBQVUsQ0FBQyxHQUFHLEVBQUUsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLGlCQUFpQixJQUFJLHNJQUFzSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFRLENBQUM7UUFDM04sTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDakIsSUFBSSxNQUFNO1lBQ04sWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzdCLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFFTCxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDcEMsQ0FBQztBQUVELE1BQU0sQ0FBQyxLQUFLLFVBQVUsY0FBYztJQUNoQyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsaUJBQWlCLENBQUMsQ0FBQztBQUN6QyxDQUFDO0FBRUQsTUFBTSxpQkFBaUIsR0FBRyxJQUFJLEtBQUssRUFBaUIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluc3RhbnRpYXRlZFdhc20gfSBmcm9tIFwiLi4vLi4vd2FzbS5qc1wiO1xyXG5pbXBvcnQgeyByZWFkTGF0aW4xU3RyaW5nIH0gZnJvbSBcIi4uL3N0cmluZy5qc1wiO1xyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdGVyaW5nIGEgdHlwZSBpcyBhbiBhc3luYyBmdW5jdGlvbiBjYWxsZWQgYnkgYSBzeW5jIGZ1bmN0aW9uLiBUaGlzIGhhbmRsZXMgdGhlIGNvbnZlcnNpb24sIGFkZGluZyB0aGUgcHJvbWlzZSB0byBgQWxsRW1iaW5kUHJvbWlzZXNgLlxyXG4gKiBcclxuICogQWxzbywgYmVjYXVzZSBldmVyeSBzaW5nbGUgcmVnaXN0cmF0aW9uIGNvbWVzIHdpdGggYSBuYW1lIHRoYXQgbmVlZHMgdG8gYmUgcGFyc2VkLCB0aGlzIGFsc28gcGFyc2VzIHRoYXQgbmFtZSBmb3IgeW91LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9lbWJpbmRfcmVnaXN0ZXIoaW1wbDogSW5zdGFudGlhdGVkV2FzbSwgbmFtZVB0cjogbnVtYmVyLCBmdW5jOiAobmFtZTogc3RyaW5nKSA9PiAodm9pZCB8IFByb21pc2U8dm9pZD4pKTogdm9pZCB7XHJcbiAgICBfZW1iaW5kX3JlZ2lzdGVyX2tub3duX25hbWUoaW1wbCwgcmVhZExhdGluMVN0cmluZyhpbXBsLCBuYW1lUHRyKSwgZnVuYyk7XHJcbn1cclxuXHJcbi8qKiBcclxuICogU2FtZSBhcyBgX2VtYmluZF9yZWdpc3RlcmAsIGJ1dCBmb3Iga25vd24gKG9yIHN5bnRoZXRpYykgbmFtZXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX2VtYmluZF9yZWdpc3Rlcl9rbm93bl9uYW1lKGltcGw6IEluc3RhbnRpYXRlZFdhc20sIG5hbWU6IHN0cmluZywgZnVuYzogKG5hbWU6IHN0cmluZykgPT4gKHZvaWQgfCBQcm9taXNlPHZvaWQ+KSk6IHZvaWQge1xyXG5cclxuICAgIGNvbnN0IHByb21pc2U6IFByb21pc2U8dm9pZD4gPSAoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGxldCBoYW5kbGUgPSAwO1xyXG4gICAgICAgIC8vIEZ1biBmYWN0OiBzZXRUaW1lb3V0IGRvZXNuJ3QgZXhpc3QgaW4gV29ya2xldHMhIFxyXG4gICAgICAgIC8vIEkgZ3Vlc3MgaXQgdmFndWVseSBtYWtlcyBzZW5zZSBpbiBhIFwiZGV0ZXJtaW5pc20gaXMgZ29vZFwiIHdheSwgXHJcbiAgICAgICAgLy8gYnV0IGl0IGFsc28gc2VlbXMgZ2VuZXJhbGx5IHVzZWZ1bCB0aGVyZT9cclxuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpXHJcbiAgICAgICAgICAgIGhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4geyBjb25zb2xlLndhcm4oYFRoZSBmdW5jdGlvbiBcIiR7bmFtZX1cIiB1c2VzIGFuIHVuc3VwcG9ydGVkIGFyZ3VtZW50IG9yIHJldHVybiB0eXBlLCBhcyBpdHMgZGVwZW5kZW5jaWVzIGFyZSBub3QgcmVzb2x2aW5nLiBJdCdzIHVubGlrZWx5IHRoZSBlbWJpbmQgcHJvbWlzZSB3aWxsIHJlc29sdmUuYCk7IH0sIDEwMDApIGFzIGFueTtcclxuICAgICAgICBhd2FpdCBmdW5jKG5hbWUpO1xyXG4gICAgICAgIGlmIChoYW5kbGUpXHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChoYW5kbGUpO1xyXG4gICAgfSkoKTtcclxuXHJcbiAgICBBbGxFbWJpbmRQcm9taXNlcy5wdXNoKHByb21pc2UpO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXdhaXRBbGxFbWJpbmQoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBhd2FpdCBQcm9taXNlLmFsbChBbGxFbWJpbmRQcm9taXNlcyk7XHJcbn1cclxuXHJcbmNvbnN0IEFsbEVtYmluZFByb21pc2VzID0gbmV3IEFycmF5PFByb21pc2U8dm9pZD4+KCk7XHJcblxyXG4iXX0=