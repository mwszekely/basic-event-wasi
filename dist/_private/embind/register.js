import { InstantiatedWasm } from "../../wasm.js";
import { readLatin1String } from "../string.js";
/**
 * Registering a type is an async function called by a sync function. This handles the conversion, adding the promise to `AllEmbindPromises`.
 *
 * Also, because every single registration comes with a name that needs to be parsed, this also parses that name for you.
 */
export function _embind_register(impl, namePtr, func) {
    _embind_register_known_name(impl, readLatin1String(impl, namePtr), func);
}
/**
 * Same as `_embind_register`, but for known (or synthetic) names.
 */
export function _embind_register_known_name(_impl, name, func) {
    const promise = (async () => {
        let handle = 0;
        // Fun fact: setTimeout doesn't exist in Worklets! 
        // I guess it vaguely makes sense in a "determinism is good" way, 
        // but it also seems generally useful there?
        if (typeof setTimeout === 'function')
            handle = setTimeout(() => { console.warn(`The function "${name}" uses an unsupported argument or return type, as its dependencies are not resolving. It's unlikely the embind promise will resolve.`); }, 1000);
        await func(name);
        if (handle)
            clearTimeout(handle);
    })();
    AllEmbindPromises.push(promise);
}
export async function awaitAllEmbind() {
    await Promise.all(AllEmbindPromises);
}
const AllEmbindPromises = new Array();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVnaXN0ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvX3ByaXZhdGUvZW1iaW5kL3JlZ2lzdGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNqRCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFFaEQ7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxnQkFBZ0IsQ0FBQyxJQUFzQixFQUFFLE9BQWUsRUFBRSxJQUE4QztJQUNwSCwyQkFBMkIsQ0FBQyxJQUFJLEVBQUUsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQzdFLENBQUM7QUFFRDs7R0FFRztBQUNILE1BQU0sVUFBVSwyQkFBMkIsQ0FBQyxLQUF1QixFQUFFLElBQVksRUFBRSxJQUE4QztJQUU3SCxNQUFNLE9BQU8sR0FBa0IsQ0FBQyxLQUFLLElBQUksRUFBRTtRQUN2QyxJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUM7UUFDZixtREFBbUQ7UUFDbkQsa0VBQWtFO1FBQ2xFLDRDQUE0QztRQUM1QyxJQUFJLE9BQU8sVUFBVSxLQUFLLFVBQVU7WUFDaEMsTUFBTSxHQUFHLFVBQVUsQ0FBQyxHQUFHLEVBQUUsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLGlCQUFpQixJQUFJLHNJQUFzSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDcE4sTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDakIsSUFBSSxNQUFNO1lBQ04sWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzdCLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFFTCxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDcEMsQ0FBQztBQUVELE1BQU0sQ0FBQyxLQUFLLFVBQVUsY0FBYztJQUNoQyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsaUJBQWlCLENBQUMsQ0FBQztBQUN6QyxDQUFDO0FBRUQsTUFBTSxpQkFBaUIsR0FBRyxJQUFJLEtBQUssRUFBaUIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluc3RhbnRpYXRlZFdhc20gfSBmcm9tIFwiLi4vLi4vd2FzbS5qc1wiO1xyXG5pbXBvcnQgeyByZWFkTGF0aW4xU3RyaW5nIH0gZnJvbSBcIi4uL3N0cmluZy5qc1wiO1xyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdGVyaW5nIGEgdHlwZSBpcyBhbiBhc3luYyBmdW5jdGlvbiBjYWxsZWQgYnkgYSBzeW5jIGZ1bmN0aW9uLiBUaGlzIGhhbmRsZXMgdGhlIGNvbnZlcnNpb24sIGFkZGluZyB0aGUgcHJvbWlzZSB0byBgQWxsRW1iaW5kUHJvbWlzZXNgLlxyXG4gKiBcclxuICogQWxzbywgYmVjYXVzZSBldmVyeSBzaW5nbGUgcmVnaXN0cmF0aW9uIGNvbWVzIHdpdGggYSBuYW1lIHRoYXQgbmVlZHMgdG8gYmUgcGFyc2VkLCB0aGlzIGFsc28gcGFyc2VzIHRoYXQgbmFtZSBmb3IgeW91LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9lbWJpbmRfcmVnaXN0ZXIoaW1wbDogSW5zdGFudGlhdGVkV2FzbSwgbmFtZVB0cjogbnVtYmVyLCBmdW5jOiAobmFtZTogc3RyaW5nKSA9PiAodm9pZCB8IFByb21pc2U8dm9pZD4pKTogdm9pZCB7XHJcbiAgICBfZW1iaW5kX3JlZ2lzdGVyX2tub3duX25hbWUoaW1wbCwgcmVhZExhdGluMVN0cmluZyhpbXBsLCBuYW1lUHRyKSwgZnVuYyk7XHJcbn1cclxuXHJcbi8qKiBcclxuICogU2FtZSBhcyBgX2VtYmluZF9yZWdpc3RlcmAsIGJ1dCBmb3Iga25vd24gKG9yIHN5bnRoZXRpYykgbmFtZXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX2VtYmluZF9yZWdpc3Rlcl9rbm93bl9uYW1lKF9pbXBsOiBJbnN0YW50aWF0ZWRXYXNtLCBuYW1lOiBzdHJpbmcsIGZ1bmM6IChuYW1lOiBzdHJpbmcpID0+ICh2b2lkIHwgUHJvbWlzZTx2b2lkPikpOiB2b2lkIHtcclxuXHJcbiAgICBjb25zdCBwcm9taXNlOiBQcm9taXNlPHZvaWQ+ID0gKGFzeW5jICgpID0+IHtcclxuICAgICAgICBsZXQgaGFuZGxlID0gMDtcclxuICAgICAgICAvLyBGdW4gZmFjdDogc2V0VGltZW91dCBkb2Vzbid0IGV4aXN0IGluIFdvcmtsZXRzISBcclxuICAgICAgICAvLyBJIGd1ZXNzIGl0IHZhZ3VlbHkgbWFrZXMgc2Vuc2UgaW4gYSBcImRldGVybWluaXNtIGlzIGdvb2RcIiB3YXksIFxyXG4gICAgICAgIC8vIGJ1dCBpdCBhbHNvIHNlZW1zIGdlbmVyYWxseSB1c2VmdWwgdGhlcmU/XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgICAgICBoYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHsgY29uc29sZS53YXJuKGBUaGUgZnVuY3Rpb24gXCIke25hbWV9XCIgdXNlcyBhbiB1bnN1cHBvcnRlZCBhcmd1bWVudCBvciByZXR1cm4gdHlwZSwgYXMgaXRzIGRlcGVuZGVuY2llcyBhcmUgbm90IHJlc29sdmluZy4gSXQncyB1bmxpa2VseSB0aGUgZW1iaW5kIHByb21pc2Ugd2lsbCByZXNvbHZlLmApOyB9LCAxMDAwKTtcclxuICAgICAgICBhd2FpdCBmdW5jKG5hbWUpO1xyXG4gICAgICAgIGlmIChoYW5kbGUpXHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChoYW5kbGUpO1xyXG4gICAgfSkoKTtcclxuXHJcbiAgICBBbGxFbWJpbmRQcm9taXNlcy5wdXNoKHByb21pc2UpO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXdhaXRBbGxFbWJpbmQoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBhd2FpdCBQcm9taXNlLmFsbChBbGxFbWJpbmRQcm9taXNlcyk7XHJcbn1cclxuXHJcbmNvbnN0IEFsbEVtYmluZFByb21pc2VzID0gbmV3IEFycmF5PFByb21pc2U8dm9pZD4+KCk7XHJcblxyXG4iXX0=