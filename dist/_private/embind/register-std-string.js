import { readSizeT } from "../../util/read-sizet.js";
import { getSizeTSize } from "../../util/sizet.js";
import { writeSizeT } from "../../util/write-sizet.js";
import { writeUint16 } from "../../util/write-uint16.js";
import { writeUint32 } from "../../util/write-uint32.js";
import { writeUint8 } from "../../util/write-uint8.js";
import { stringToUtf16, stringToUtf32, stringToUtf8, utf16ToStringL, utf32ToStringL, utf8ToStringL } from "../string.js";
import { finalizeType } from "./finalize.js";
import { _embind_register } from "./register.js";
// Shared between std::string and std::wstring
export function _embind_register_std_string_any(impl, typePtr, charWidth, namePtr) {
    const utfToStringL = (charWidth == 1) ? utf8ToStringL : (charWidth == 2) ? utf16ToStringL : utf32ToStringL;
    const stringToUtf = (charWidth == 1) ? stringToUtf8 : (charWidth == 2) ? stringToUtf16 : stringToUtf32;
    const UintArray = (charWidth == 1) ? Uint8Array : (charWidth == 2) ? Uint16Array : Uint32Array;
    const writeUint = (charWidth == 1) ? writeUint8 : (charWidth == 2) ? writeUint16 : writeUint32;
    _embind_register(impl, namePtr, (name) => {
        const fromWireType = (ptr) => {
            // The wire type is a pointer to a "struct" (not really a struct in the usual sense...
            // except maybe in newer C versions I guess) where 
            // the first field is a size_t representing the length,
            // And the second "field" is the string data itself,
            // finally all ended with an extra null byte.
            const length = readSizeT(impl, ptr);
            const payload = ptr + getSizeTSize(impl);
            const decodeStartPtr = payload;
            const str = utfToStringL(impl, decodeStartPtr, length);
            return {
                jsValue: str,
                wireValue: ptr,
                stackDestructor: () => {
                    // This call to _free happens because Embind calls malloc during its toWireType function.
                    // Surely there's a way to avoid this copy of a copy of a copy though, right? Right?
                    impl.exports.free(ptr);
                }
            };
        };
        const toWireType = (str) => {
            const valueAsArrayBufferInJS = new UintArray(stringToUtf(str));
            // Is it more or less clear with all these variables explicitly named?
            // Hopefully more, at least slightly.
            const charCountWithoutNull = valueAsArrayBufferInJS.length;
            const charCountWithNull = charCountWithoutNull + 1;
            const byteCountWithoutNull = charCountWithoutNull * charWidth;
            const byteCountWithNull = charCountWithNull * charWidth;
            // 1. (m)allocate space for the struct above
            const wasmStringStruct = impl.exports.malloc(getSizeTSize(impl) + byteCountWithNull);
            // 2. Write the length of the string to the struct
            const stringStart = wasmStringStruct + getSizeTSize(impl);
            writeSizeT(impl, wasmStringStruct, charCountWithoutNull);
            // 3. Write the string data to the struct
            const destination = new UintArray(impl.exports.memory.buffer, stringStart, byteCountWithoutNull);
            destination.set(valueAsArrayBufferInJS);
            // 4. Write a null byte
            writeUint(impl, stringStart + byteCountWithoutNull, 0);
            return {
                stackDestructor: () => impl.exports.free(wasmStringStruct),
                wireValue: wasmStringStruct,
                jsValue: str
            };
        };
        finalizeType(impl, name, {
            typeId: typePtr,
            fromWireType,
            toWireType,
        });
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVnaXN0ZXItc3RkLXN0cmluZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9fcHJpdmF0ZS9lbWJpbmQvcmVnaXN0ZXItc3RkLXN0cmluZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDckQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ25ELE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUN2RCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDekQsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQ3pELE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUV2RCxPQUFPLEVBQUUsYUFBYSxFQUFFLGFBQWEsRUFBRSxZQUFZLEVBQUUsY0FBYyxFQUFFLGNBQWMsRUFBRSxhQUFhLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDekgsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUM3QyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFHakQsOENBQThDO0FBQzlDLE1BQU0sVUFBVSwrQkFBK0IsQ0FBQyxJQUFzQixFQUFFLE9BQWUsRUFBRSxTQUFvQixFQUFFLE9BQWU7SUFFMUgsTUFBTSxZQUFZLEdBQUcsQ0FBQyxTQUFTLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDO0lBQzNHLE1BQU0sV0FBVyxHQUFHLENBQUMsU0FBUyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FB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O2dCQUMxRCxTQUFTLEVBQUUsZ0JBQWdCO2dCQUMzQixPQUFPLEVBQUUsR0FBRzthQUNmLENBQUM7UUFDTixDQUFDLENBQUM7UUFFRixZQUFZLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRTtZQUNyQixNQUFNLEVBQUUsT0FBTztZQUNmLFlBQVk7WUFDWixVQUFVO1NBQ2IsQ0FBQyxDQUFDO0lBQ1AsQ0FBQyxDQUFDLENBQUM7QUFDUCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVhZFNpemVUIH0gZnJvbSBcIi4uLy4uL3V0aWwvcmVhZC1zaXpldC5qc1wiO1xyXG5pbXBvcnQgeyBnZXRTaXplVFNpemUgfSBmcm9tIFwiLi4vLi4vdXRpbC9zaXpldC5qc1wiO1xyXG5pbXBvcnQgeyB3cml0ZVNpemVUIH0gZnJvbSBcIi4uLy4uL3V0aWwvd3JpdGUtc2l6ZXQuanNcIjtcclxuaW1wb3J0IHsgd3JpdGVVaW50MTYgfSBmcm9tIFwiLi4vLi4vdXRpbC93cml0ZS11aW50MTYuanNcIjtcclxuaW1wb3J0IHsgd3JpdGVVaW50MzIgfSBmcm9tIFwiLi4vLi4vdXRpbC93cml0ZS11aW50MzIuanNcIjtcclxuaW1wb3J0IHsgd3JpdGVVaW50OCB9IGZyb20gXCIuLi8uLi91dGlsL3dyaXRlLXVpbnQ4LmpzXCI7XHJcbmltcG9ydCB0eXBlIHsgSW5zdGFudGlhdGVkV2FzbSB9IGZyb20gXCIuLi8uLi93YXNtLmpzXCI7XHJcbmltcG9ydCB7IHN0cmluZ1RvVXRmMTYsIHN0cmluZ1RvVXRmMzIsIHN0cmluZ1RvVXRmOCwgdXRmMTZUb1N0cmluZ0wsIHV0ZjMyVG9TdHJpbmdMLCB1dGY4VG9TdHJpbmdMIH0gZnJvbSBcIi4uL3N0cmluZy5qc1wiO1xyXG5pbXBvcnQgeyBmaW5hbGl6ZVR5cGUgfSBmcm9tIFwiLi9maW5hbGl6ZS5qc1wiO1xyXG5pbXBvcnQgeyBfZW1iaW5kX3JlZ2lzdGVyIH0gZnJvbSBcIi4vcmVnaXN0ZXIuanNcIjtcclxuaW1wb3J0IHR5cGUgeyBXaXJlQ29udmVyc2lvblJlc3VsdCB9IGZyb20gXCIuL3R5cGVzLmpzXCI7XHJcblxyXG4vLyBTaGFyZWQgYmV0d2VlbiBzdGQ6OnN0cmluZyBhbmQgc3RkOjp3c3RyaW5nXHJcbmV4cG9ydCBmdW5jdGlvbiBfZW1iaW5kX3JlZ2lzdGVyX3N0ZF9zdHJpbmdfYW55KGltcGw6IEluc3RhbnRpYXRlZFdhc20sIHR5cGVQdHI6IG51bWJlciwgY2hhcldpZHRoOiAxIHwgMiB8IDQsIG5hbWVQdHI6IG51bWJlcik6IHZvaWQge1xyXG5cclxuICAgIGNvbnN0IHV0ZlRvU3RyaW5nTCA9IChjaGFyV2lkdGggPT0gMSkgPyB1dGY4VG9TdHJpbmdMIDogKGNoYXJXaWR0aCA9PSAyKSA/IHV0ZjE2VG9TdHJpbmdMIDogdXRmMzJUb1N0cmluZ0w7XHJcbiAgICBjb25zdCBzdHJpbmdUb1V0ZiA9IChjaGFyV2lkdGggPT0gMSkgPyBzdHJpbmdUb1V0ZjggOiAoY2hhcldpZHRoID09IDIpID8gc3RyaW5nVG9VdGYxNiA6IHN0cmluZ1RvVXRmMzI7XHJcbiAgICBjb25zdCBVaW50QXJyYXkgPSAoY2hhcldpZHRoID09IDEpID8gVWludDhBcnJheSA6IChjaGFyV2lkdGggPT0gMikgPyBVaW50MTZBcnJheSA6IFVpbnQzMkFycmF5O1xyXG4gICAgY29uc3Qgd3JpdGVVaW50ID0gKGNoYXJXaWR0aCA9PSAxKSA/IHdyaXRlVWludDggOiAoY2hhcldpZHRoID09IDIpID8gd3JpdGVVaW50MTYgOiB3cml0ZVVpbnQzMjtcclxuXHJcblxyXG4gICAgX2VtYmluZF9yZWdpc3RlcihpbXBsLCBuYW1lUHRyLCAobmFtZSkgPT4ge1xyXG5cclxuICAgICAgICBjb25zdCBmcm9tV2lyZVR5cGUgPSAocHRyOiBudW1iZXIpID0+IHtcclxuICAgICAgICAgICAgLy8gVGhlIHdpcmUgdHlwZSBpcyBhIHBvaW50ZXIgdG8gYSBcInN0cnVjdFwiIChub3QgcmVhbGx5IGEgc3RydWN0IGluIHRoZSB1c3VhbCBzZW5zZS4uLlxyXG4gICAgICAgICAgICAvLyBleGNlcHQgbWF5YmUgaW4gbmV3ZXIgQyB2ZXJzaW9ucyBJIGd1ZXNzKSB3aGVyZSBcclxuICAgICAgICAgICAgLy8gdGhlIGZpcnN0IGZpZWxkIGlzIGEgc2l6ZV90IHJlcHJlc2VudGluZyB0aGUgbGVuZ3RoLFxyXG4gICAgICAgICAgICAvLyBBbmQgdGhlIHNlY29uZCBcImZpZWxkXCIgaXMgdGhlIHN0cmluZyBkYXRhIGl0c2VsZixcclxuICAgICAgICAgICAgLy8gZmluYWxseSBhbGwgZW5kZWQgd2l0aCBhbiBleHRyYSBudWxsIGJ5dGUuXHJcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHJlYWRTaXplVChpbXBsLCBwdHIpO1xyXG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gcHRyICsgZ2V0U2l6ZVRTaXplKGltcGwpO1xyXG4gICAgICAgICAgICBjb25zdCBkZWNvZGVTdGFydFB0ciA9IHBheWxvYWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0ciA9IHV0ZlRvU3RyaW5nTChpbXBsLCBkZWNvZGVTdGFydFB0ciwgbGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBqc1ZhbHVlOiBzdHIsXHJcbiAgICAgICAgICAgICAgICB3aXJlVmFsdWU6IHB0cixcclxuICAgICAgICAgICAgICAgIHN0YWNrRGVzdHJ1Y3RvcjogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgY2FsbCB0byBfZnJlZSBoYXBwZW5zIGJlY2F1c2UgRW1iaW5kIGNhbGxzIG1hbGxvYyBkdXJpbmcgaXRzIHRvV2lyZVR5cGUgZnVuY3Rpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VyZWx5IHRoZXJlJ3MgYSB3YXkgdG8gYXZvaWQgdGhpcyBjb3B5IG9mIGEgY29weSBvZiBhIGNvcHkgdGhvdWdoLCByaWdodD8gUmlnaHQ/XHJcbiAgICAgICAgICAgICAgICAgICAgaW1wbC5leHBvcnRzLmZyZWUocHRyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCB0b1dpcmVUeXBlID0gKHN0cjogc3RyaW5nKTogV2lyZUNvbnZlcnNpb25SZXN1bHQ8bnVtYmVyLCBzdHJpbmc+ID0+IHtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlQXNBcnJheUJ1ZmZlckluSlMgPSBuZXcgVWludEFycmF5KHN0cmluZ1RvVXRmKHN0cikpO1xyXG5cclxuICAgICAgICAgICAgLy8gSXMgaXQgbW9yZSBvciBsZXNzIGNsZWFyIHdpdGggYWxsIHRoZXNlIHZhcmlhYmxlcyBleHBsaWNpdGx5IG5hbWVkP1xyXG4gICAgICAgICAgICAvLyBIb3BlZnVsbHkgbW9yZSwgYXQgbGVhc3Qgc2xpZ2h0bHkuXHJcbiAgICAgICAgICAgIGNvbnN0IGNoYXJDb3VudFdpdGhvdXROdWxsID0gdmFsdWVBc0FycmF5QnVmZmVySW5KUy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoYXJDb3VudFdpdGhOdWxsID0gY2hhckNvdW50V2l0aG91dE51bGwgKyAxO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgYnl0ZUNvdW50V2l0aG91dE51bGwgPSBjaGFyQ291bnRXaXRob3V0TnVsbCAqIGNoYXJXaWR0aDtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZUNvdW50V2l0aE51bGwgPSBjaGFyQ291bnRXaXRoTnVsbCAqIGNoYXJXaWR0aDtcclxuXHJcbiAgICAgICAgICAgIC8vIDEuIChtKWFsbG9jYXRlIHNwYWNlIGZvciB0aGUgc3RydWN0IGFib3ZlXHJcbiAgICAgICAgICAgIGNvbnN0IHdhc21TdHJpbmdTdHJ1Y3QgPSBpbXBsLmV4cG9ydHMubWFsbG9jKGdldFNpemVUU2l6ZShpbXBsKSArIGJ5dGVDb3VudFdpdGhOdWxsKTtcclxuXHJcbiAgICAgICAgICAgIC8vIDIuIFdyaXRlIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZyB0byB0aGUgc3RydWN0XHJcbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ1N0YXJ0ID0gd2FzbVN0cmluZ1N0cnVjdCArIGdldFNpemVUU2l6ZShpbXBsKTtcclxuICAgICAgICAgICAgd3JpdGVTaXplVChpbXBsLCB3YXNtU3RyaW5nU3RydWN0LCBjaGFyQ291bnRXaXRob3V0TnVsbCk7XHJcblxyXG4gICAgICAgICAgICAvLyAzLiBXcml0ZSB0aGUgc3RyaW5nIGRhdGEgdG8gdGhlIHN0cnVjdFxyXG4gICAgICAgICAgICBjb25zdCBkZXN0aW5hdGlvbiA9IG5ldyBVaW50QXJyYXkoaW1wbC5leHBvcnRzLm1lbW9yeS5idWZmZXIsIHN0cmluZ1N0YXJ0LCBieXRlQ291bnRXaXRob3V0TnVsbCk7XHJcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnNldCh2YWx1ZUFzQXJyYXlCdWZmZXJJbkpTKTtcclxuXHJcbiAgICAgICAgICAgIC8vIDQuIFdyaXRlIGEgbnVsbCBieXRlXHJcbiAgICAgICAgICAgIHdyaXRlVWludChpbXBsLCBzdHJpbmdTdGFydCArIGJ5dGVDb3VudFdpdGhvdXROdWxsLCAwKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzdGFja0Rlc3RydWN0b3I6ICgpID0+IGltcGwuZXhwb3J0cy5mcmVlKHdhc21TdHJpbmdTdHJ1Y3QpLFxyXG4gICAgICAgICAgICAgICAgd2lyZVZhbHVlOiB3YXNtU3RyaW5nU3RydWN0LFxyXG4gICAgICAgICAgICAgICAganNWYWx1ZTogc3RyXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZmluYWxpemVUeXBlKGltcGwsIG5hbWUsIHtcclxuICAgICAgICAgICAgdHlwZUlkOiB0eXBlUHRyLFxyXG4gICAgICAgICAgICBmcm9tV2lyZVR5cGUsXHJcbiAgICAgICAgICAgIHRvV2lyZVR5cGUsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG4iXX0=