import { finalizeType } from "../_private/embind/finalize.js";
import { _embind_register } from "../_private/embind/register.js";
export function _embind_register_integer(typePtr, namePtr, byteWidth, minValue, _maxValue) {
    _embind_register(this, namePtr, (name) => {
        const isUnsignedType = (minValue === 0);
        const fromWireType = isUnsignedType ? fromWireTypeU(byteWidth) : fromWireTypeS(byteWidth);
        // TODO: min/maxValue aren't used for bounds checking,
        // but if they are, make sure to adjust maxValue for the same signed/unsigned type issue
        // on 32-bit signed int types:
        // maxValue = fromWireType(maxValue);
        finalizeType(this, name, {
            typeId: typePtr,
            fromWireType,
            toWireType: (jsValue) => ({ wireValue: jsValue, jsValue })
        });
    });
}
// We need a separate function for unsigned conversion because WASM only has signed types, 
// even when languages have unsigned types, and it expects the client to manage the transition.
// So this is us, managing the transition.
function fromWireTypeU(byteWidth) {
    // Shift out all the bits higher than what would fit in this integer type,
    // but in particular make sure the negative bit gets cleared out by the >>> at the end.
    const overflowBitCount = 32 - 8 * byteWidth;
    return function (wireValue) {
        return { wireValue, jsValue: ((wireValue << overflowBitCount) >>> overflowBitCount) };
    };
}
function fromWireTypeS(byteWidth) {
    // Shift out all the bits higher than what would fit in this integer type.
    const overflowBitCount = 32 - 8 * byteWidth;
    return function (wireValue) {
        return { wireValue, jsValue: ((wireValue << overflowBitCount) >> overflowBitCount) };
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW1iaW5kX3JlZ2lzdGVyX2ludGVnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvZW52L2VtYmluZF9yZWdpc3Rlcl9pbnRlZ2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUM5RCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUlsRSxNQUFNLFVBQVUsd0JBQXdCLENBQXlCLE9BQWUsRUFBRSxPQUFlLEVBQUUsU0FBaUIsRUFBRSxRQUFnQixFQUFFLFNBQWlCO0lBQ3JKLGdCQUFnQixDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsQ0FBQyxJQUFJLEVBQUUsRUFBRTtRQUVyQyxNQUFNLGNBQWMsR0FBRyxDQUFDLFFBQVEsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUN4QyxNQUFNLFlBQVksR0FBRyxjQUFjLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRTFGLHNEQUFzRDtRQUN0RCx3RkFBd0Y7UUFDeEYsOEJBQThCO1FBQzlCLHFDQUFxQztRQUVyQyxZQUFZLENBQWlCLElBQUksRUFBRSxJQUFJLEVBQUU7WUFDckMsTUFBTSxFQUFFLE9BQU87WUFDZixZQUFZO1lBQ1osVUFBVSxFQUFFLENBQUMsT0FBZSxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsQ0FBQztTQUNyRSxDQUFDLENBQUM7SUFDUCxDQUFDLENBQUMsQ0FBQztBQUNQLENBQUM7QUFHRCwyRkFBMkY7QUFDM0YsK0ZBQStGO0FBQy9GLDBDQUEwQztBQUMxQyxTQUFTLGFBQWEsQ0FBQyxTQUFpQjtJQUNwQywwRUFBMEU7SUFDMUUsdUZBQXVGO0lBQ3ZGLE1BQU0sZ0JBQWdCLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxTQUFTLENBQUM7SUFDNUMsT0FBTyxVQUFVLFNBQWlCO1FBQzlCLE9BQU8sRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQyxTQUFTLElBQUksZ0JBQWdCLENBQUMsS0FBSyxnQkFBZ0IsQ0FBQyxFQUFFLENBQUM7SUFDMUYsQ0FBQyxDQUFBO0FBQ0wsQ0FBQztBQUVELFNBQVMsYUFBYSxDQUFDLFNBQWlCO0lBQ3BDLDBFQUEwRTtJQUMxRSxNQUFNLGdCQUFnQixHQUFHLEVBQUUsR0FBRyxDQUFDLEdBQUcsU0FBUyxDQUFDO0lBQzVDLE9BQU8sVUFBVSxTQUFpQjtRQUM5QixPQUFPLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUMsU0FBUyxJQUFJLGdCQUFnQixDQUFDLElBQUksZ0JBQWdCLENBQUMsRUFBRSxDQUFDO0lBQ3pGLENBQUMsQ0FBQTtBQUNMLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmaW5hbGl6ZVR5cGUgfSBmcm9tIFwiLi4vX3ByaXZhdGUvZW1iaW5kL2ZpbmFsaXplLmpzXCI7XHJcbmltcG9ydCB7IF9lbWJpbmRfcmVnaXN0ZXIgfSBmcm9tIFwiLi4vX3ByaXZhdGUvZW1iaW5kL3JlZ2lzdGVyLmpzXCI7XHJcbmltcG9ydCB0eXBlIHsgRW1ib3VuZFJlZ2lzdGVyZWRUeXBlIH0gZnJvbSBcIi4uL19wcml2YXRlL2VtYmluZC90eXBlcy5qc1wiO1xyXG5pbXBvcnQgdHlwZSB7IEluc3RhbnRpYXRlZFdhc20gfSBmcm9tIFwiLi4vd2FzbS5qc1wiO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9lbWJpbmRfcmVnaXN0ZXJfaW50ZWdlcih0aGlzOiBJbnN0YW50aWF0ZWRXYXNtLCB0eXBlUHRyOiBudW1iZXIsIG5hbWVQdHI6IG51bWJlciwgYnl0ZVdpZHRoOiBudW1iZXIsIG1pblZhbHVlOiBudW1iZXIsIF9tYXhWYWx1ZTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICBfZW1iaW5kX3JlZ2lzdGVyKHRoaXMsIG5hbWVQdHIsIChuYW1lKSA9PiB7XHJcblxyXG4gICAgICAgIGNvbnN0IGlzVW5zaWduZWRUeXBlID0gKG1pblZhbHVlID09PSAwKTtcclxuICAgICAgICBjb25zdCBmcm9tV2lyZVR5cGUgPSBpc1Vuc2lnbmVkVHlwZSA/IGZyb21XaXJlVHlwZVUoYnl0ZVdpZHRoKSA6IGZyb21XaXJlVHlwZVMoYnl0ZVdpZHRoKTtcclxuXHJcbiAgICAgICAgLy8gVE9ETzogbWluL21heFZhbHVlIGFyZW4ndCB1c2VkIGZvciBib3VuZHMgY2hlY2tpbmcsXHJcbiAgICAgICAgLy8gYnV0IGlmIHRoZXkgYXJlLCBtYWtlIHN1cmUgdG8gYWRqdXN0IG1heFZhbHVlIGZvciB0aGUgc2FtZSBzaWduZWQvdW5zaWduZWQgdHlwZSBpc3N1ZVxyXG4gICAgICAgIC8vIG9uIDMyLWJpdCBzaWduZWQgaW50IHR5cGVzOlxyXG4gICAgICAgIC8vIG1heFZhbHVlID0gZnJvbVdpcmVUeXBlKG1heFZhbHVlKTtcclxuXHJcbiAgICAgICAgZmluYWxpemVUeXBlPG51bWJlciwgbnVtYmVyPih0aGlzLCBuYW1lLCB7XHJcbiAgICAgICAgICAgIHR5cGVJZDogdHlwZVB0cixcclxuICAgICAgICAgICAgZnJvbVdpcmVUeXBlLFxyXG4gICAgICAgICAgICB0b1dpcmVUeXBlOiAoanNWYWx1ZTogbnVtYmVyKSA9PiAoeyB3aXJlVmFsdWU6IGpzVmFsdWUsIGpzVmFsdWUgfSlcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5cclxuLy8gV2UgbmVlZCBhIHNlcGFyYXRlIGZ1bmN0aW9uIGZvciB1bnNpZ25lZCBjb252ZXJzaW9uIGJlY2F1c2UgV0FTTSBvbmx5IGhhcyBzaWduZWQgdHlwZXMsIFxyXG4vLyBldmVuIHdoZW4gbGFuZ3VhZ2VzIGhhdmUgdW5zaWduZWQgdHlwZXMsIGFuZCBpdCBleHBlY3RzIHRoZSBjbGllbnQgdG8gbWFuYWdlIHRoZSB0cmFuc2l0aW9uLlxyXG4vLyBTbyB0aGlzIGlzIHVzLCBtYW5hZ2luZyB0aGUgdHJhbnNpdGlvbi5cclxuZnVuY3Rpb24gZnJvbVdpcmVUeXBlVShieXRlV2lkdGg6IG51bWJlcik6IEVtYm91bmRSZWdpc3RlcmVkVHlwZTxudW1iZXIsIG51bWJlcj5bXCJmcm9tV2lyZVR5cGVcIl0ge1xyXG4gICAgLy8gU2hpZnQgb3V0IGFsbCB0aGUgYml0cyBoaWdoZXIgdGhhbiB3aGF0IHdvdWxkIGZpdCBpbiB0aGlzIGludGVnZXIgdHlwZSxcclxuICAgIC8vIGJ1dCBpbiBwYXJ0aWN1bGFyIG1ha2Ugc3VyZSB0aGUgbmVnYXRpdmUgYml0IGdldHMgY2xlYXJlZCBvdXQgYnkgdGhlID4+PiBhdCB0aGUgZW5kLlxyXG4gICAgY29uc3Qgb3ZlcmZsb3dCaXRDb3VudCA9IDMyIC0gOCAqIGJ5dGVXaWR0aDtcclxuICAgIHJldHVybiBmdW5jdGlvbiAod2lyZVZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgICByZXR1cm4geyB3aXJlVmFsdWUsIGpzVmFsdWU6ICgod2lyZVZhbHVlIDw8IG92ZXJmbG93Qml0Q291bnQpID4+PiBvdmVyZmxvd0JpdENvdW50KSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBmcm9tV2lyZVR5cGVTKGJ5dGVXaWR0aDogbnVtYmVyKTogRW1ib3VuZFJlZ2lzdGVyZWRUeXBlPG51bWJlciwgbnVtYmVyPltcImZyb21XaXJlVHlwZVwiXSB7XHJcbiAgICAvLyBTaGlmdCBvdXQgYWxsIHRoZSBiaXRzIGhpZ2hlciB0aGFuIHdoYXQgd291bGQgZml0IGluIHRoaXMgaW50ZWdlciB0eXBlLlxyXG4gICAgY29uc3Qgb3ZlcmZsb3dCaXRDb3VudCA9IDMyIC0gOCAqIGJ5dGVXaWR0aDtcclxuICAgIHJldHVybiBmdW5jdGlvbiAod2lyZVZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgICByZXR1cm4geyB3aXJlVmFsdWUsIGpzVmFsdWU6ICgod2lyZVZhbHVlIDw8IG92ZXJmbG93Qml0Q291bnQpID4+IG92ZXJmbG93Qml0Q291bnQpIH07XHJcbiAgICB9XHJcbn0iXX0=