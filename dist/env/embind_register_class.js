import { renameFunction } from "../_private/embind/create-named-function.js";
import { EmboundClass, EmboundClasses, Secret } from "../_private/embind/embound-class.js";
import { finalizeType } from "../_private/embind/finalize.js";
import { getTableFunction } from "../_private/embind/get-table-function.js";
import { _embind_register } from "../_private/embind/register.js";
import { InstantiatedWasm } from "../wasm.js";
export { inspectClassByPointer } from "../_private/embind/embound-class.js";
export function _embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualTypePtr, upcastSignature, upcastPtr, downcastSignature, downcastPtr, namePtr, destructorSignature, rawDestructorPtr) {
    /**
     * Note: _embind_register_class doesn't have a corresponding `finalize` version,
     * like value_array and value_object have, which is fine I guess?
     *
     * But it means that we can't just create a class pre-installed with everything it needs--
     * we need to add member functions and properties and such as we get them, and we
     * never really know when we're done.
     */
    _embind_register(this, namePtr, async (name) => {
        const rawDestructorInvoker = getTableFunction(this, destructorSignature, rawDestructorPtr);
        // TODO(?) It's probably not necessary to have EmboundClasses and this.embind basically be the same exact thing.
        EmboundClasses[rawType] = this.embind[name] = renameFunction(name, 
        // Unlike the constructor, the destructor is known early enough to assign now.
        // Probably because destructors can't be overloaded by anything so there's only ever one.
        // Anyway, assign it to this new class.
        class extends EmboundClass {
            static _destructor = rawDestructorInvoker;
        });
        function fromWireType(_this) { const jsValue = new EmboundClasses[rawType](Secret, _this); return { wireValue: _this, jsValue, stackDestructor: () => jsValue[Symbol.dispose]() }; }
        function toWireType(jsObject) {
            return {
                wireValue: jsObject._this,
                jsValue: jsObject,
                // Note: no destructors for any of these,
                // because they're just for value-types-as-object-types.
                // Adding it here wouldn't work properly, because it assumes
                // we own the object (when converting from a JS string to std::string, we effectively do, but not here)
            };
        }
        // Wish other types included pointer TypeIDs with them too...
        finalizeType(this, name, { typeId: rawType, fromWireType, toWireType });
        finalizeType(this, `${name}*`, { typeId: rawPointerType, fromWireType, toWireType });
        finalizeType(this, `${name} const*`, { typeId: rawConstPointerType, fromWireType, toWireType });
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW1iaW5kX3JlZ2lzdGVyX2NsYXNzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2Vudi9lbWJpbmRfcmVnaXN0ZXJfY2xhc3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDZDQUE2QyxDQUFDO0FBQzdFLE9BQU8sRUFBRSxZQUFZLEVBQUUsY0FBYyxFQUFFLE1BQU0sRUFBRSxNQUFNLHFDQUFxQyxDQUFDO0FBQzNGLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUM5RCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSwwQ0FBMEMsQ0FBQztBQUM1RSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUVsRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFDOUMsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFHNUUsTUFBTSxVQUFVLHNCQUFzQixDQUVsQyxPQUFlLEVBQ2YsY0FBc0IsRUFDdEIsbUJBQTJCLEVBQzNCLGdCQUF3QixFQUN4QixzQkFBOEIsRUFDOUIsZ0JBQXdCLEVBQ3hCLGVBQXVCLEVBQ3ZCLFNBQWlCLEVBQ2pCLGlCQUF5QixFQUN6QixXQUFtQixFQUNuQixPQUFlLEVBQ2YsbUJBQTJCLEVBQzNCLGdCQUF3QjtJQUV4Qjs7Ozs7OztPQU9HO0lBRUgsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLEVBQUU7UUFDM0MsTUFBTSxvQkFBb0IsR0FBRyxnQkFBZ0IsQ0FBMEIsSUFBSSxFQUFFLG1CQUFtQixFQUFFLGdCQUFnQixDQUFDLENBQUM7UUFFcEgsZ0hBQWdIO1FBQ2hILGNBQWMsQ0FBQyxPQUFPLENBQUMsR0FBSSxJQUFJLENBQUMsTUFBYyxDQUFDLElBQUksQ0FBQyxHQUFHLGNBQWMsQ0FBQyxJQUFJO1FBQ3RFLDhFQUE4RTtRQUM5RSx5RkFBeUY7UUFDekYsdUNBQXVDO1FBQ3ZDLEtBQU0sU0FBUSxZQUFZO1lBQ3RCLE1BQU0sQ0FBQyxXQUFXLEdBQUcsb0JBQW9CLENBQUM7U0FDdEMsQ0FBQyxDQUFDO1FBRWQsU0FBUyxZQUFZLENBQUMsS0FBYSxJQUFnRCxNQUFNLE9BQU8sR0FBRyxJQUFJLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsZUFBZSxFQUFFLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEVBQUUsRUFBRSxDQUFBLENBQUMsQ0FBQztRQUN2TyxTQUFTLFVBQVUsQ0FBQyxRQUFzQjtZQUN0QyxPQUFPO2dCQUNILFNBQVMsRUFBRyxRQUFnQixDQUFDLEtBQUs7Z0JBQ2xDLE9BQU8sRUFBRSxRQUFRO2dCQUNqQix5Q0FBeUM7Z0JBQ3pDLHdEQUF3RDtnQkFDeEQsNERBQTREO2dCQUM1RCx1R0FBdUc7YUFDMUcsQ0FBQztRQUNOLENBQUM7UUFFRCw2REFBNkQ7UUFDN0QsWUFBWSxDQUF1QixJQUFJLEVBQUUsSUFBSSxFQUFFLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxZQUFZLEVBQUUsVUFBVSxFQUFFLENBQUMsQ0FBQztRQUM5RixZQUFZLENBQXVCLElBQUksRUFBRSxHQUFHLElBQUksR0FBRyxFQUFFLEVBQUUsTUFBTSxFQUFFLGNBQWMsRUFBRSxZQUFZLEVBQUUsVUFBVSxFQUFFLENBQUMsQ0FBQztRQUMzRyxZQUFZLENBQXVCLElBQUksRUFBRSxHQUFHLElBQUksU0FBUyxFQUFFLEVBQUUsTUFBTSxFQUFFLG1CQUFtQixFQUFFLFlBQVksRUFBRSxVQUFVLEVBQUUsQ0FBQyxDQUFDO0lBQzFILENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlbmFtZUZ1bmN0aW9uIH0gZnJvbSBcIi4uL19wcml2YXRlL2VtYmluZC9jcmVhdGUtbmFtZWQtZnVuY3Rpb24uanNcIjtcclxuaW1wb3J0IHsgRW1ib3VuZENsYXNzLCBFbWJvdW5kQ2xhc3NlcywgU2VjcmV0IH0gZnJvbSBcIi4uL19wcml2YXRlL2VtYmluZC9lbWJvdW5kLWNsYXNzLmpzXCI7XHJcbmltcG9ydCB7IGZpbmFsaXplVHlwZSB9IGZyb20gXCIuLi9fcHJpdmF0ZS9lbWJpbmQvZmluYWxpemUuanNcIjtcclxuaW1wb3J0IHsgZ2V0VGFibGVGdW5jdGlvbiB9IGZyb20gXCIuLi9fcHJpdmF0ZS9lbWJpbmQvZ2V0LXRhYmxlLWZ1bmN0aW9uLmpzXCI7XHJcbmltcG9ydCB7IF9lbWJpbmRfcmVnaXN0ZXIgfSBmcm9tIFwiLi4vX3ByaXZhdGUvZW1iaW5kL3JlZ2lzdGVyLmpzXCI7XHJcbmltcG9ydCB0eXBlIHsgV2lyZUNvbnZlcnNpb25SZXN1bHQgfSBmcm9tIFwiLi4vX3ByaXZhdGUvZW1iaW5kL3R5cGVzLmpzXCI7XHJcbmltcG9ydCB7IEluc3RhbnRpYXRlZFdhc20gfSBmcm9tIFwiLi4vd2FzbS5qc1wiO1xyXG5leHBvcnQgeyBpbnNwZWN0Q2xhc3NCeVBvaW50ZXIgfSBmcm9tIFwiLi4vX3ByaXZhdGUvZW1iaW5kL2VtYm91bmQtY2xhc3MuanNcIjtcclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX2VtYmluZF9yZWdpc3Rlcl9jbGFzcyhcclxuICAgIHRoaXM6IEluc3RhbnRpYXRlZFdhc20sXHJcbiAgICByYXdUeXBlOiBudW1iZXIsXHJcbiAgICByYXdQb2ludGVyVHlwZTogbnVtYmVyLFxyXG4gICAgcmF3Q29uc3RQb2ludGVyVHlwZTogbnVtYmVyLFxyXG4gICAgYmFzZUNsYXNzUmF3VHlwZTogbnVtYmVyLFxyXG4gICAgZ2V0QWN0dWFsVHlwZVNpZ25hdHVyZTogbnVtYmVyLFxyXG4gICAgZ2V0QWN0dWFsVHlwZVB0cjogbnVtYmVyLFxyXG4gICAgdXBjYXN0U2lnbmF0dXJlOiBudW1iZXIsXHJcbiAgICB1cGNhc3RQdHI6IG51bWJlcixcclxuICAgIGRvd25jYXN0U2lnbmF0dXJlOiBudW1iZXIsXHJcbiAgICBkb3duY2FzdFB0cjogbnVtYmVyLFxyXG4gICAgbmFtZVB0cjogbnVtYmVyLFxyXG4gICAgZGVzdHJ1Y3RvclNpZ25hdHVyZTogbnVtYmVyLFxyXG4gICAgcmF3RGVzdHJ1Y3RvclB0cjogbnVtYmVyKTogdm9pZCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb3RlOiBfZW1iaW5kX3JlZ2lzdGVyX2NsYXNzIGRvZXNuJ3QgaGF2ZSBhIGNvcnJlc3BvbmRpbmcgYGZpbmFsaXplYCB2ZXJzaW9uLFxyXG4gICAgICogbGlrZSB2YWx1ZV9hcnJheSBhbmQgdmFsdWVfb2JqZWN0IGhhdmUsIHdoaWNoIGlzIGZpbmUgSSBndWVzcz9cclxuICAgICAqIFxyXG4gICAgICogQnV0IGl0IG1lYW5zIHRoYXQgd2UgY2FuJ3QganVzdCBjcmVhdGUgYSBjbGFzcyBwcmUtaW5zdGFsbGVkIHdpdGggZXZlcnl0aGluZyBpdCBuZWVkcy0tXHJcbiAgICAgKiB3ZSBuZWVkIHRvIGFkZCBtZW1iZXIgZnVuY3Rpb25zIGFuZCBwcm9wZXJ0aWVzIGFuZCBzdWNoIGFzIHdlIGdldCB0aGVtLCBhbmQgd2VcclxuICAgICAqIG5ldmVyIHJlYWxseSBrbm93IHdoZW4gd2UncmUgZG9uZS5cclxuICAgICAqL1xyXG5cclxuICAgIF9lbWJpbmRfcmVnaXN0ZXIodGhpcywgbmFtZVB0ciwgYXN5bmMgKG5hbWUpID0+IHtcclxuICAgICAgICBjb25zdCByYXdEZXN0cnVjdG9ySW52b2tlciA9IGdldFRhYmxlRnVuY3Rpb248KF90aGlzOiBudW1iZXIpID0+IHZvaWQ+KHRoaXMsIGRlc3RydWN0b3JTaWduYXR1cmUsIHJhd0Rlc3RydWN0b3JQdHIpO1xyXG5cclxuICAgICAgICAvLyBUT0RPKD8pIEl0J3MgcHJvYmFibHkgbm90IG5lY2Vzc2FyeSB0byBoYXZlIEVtYm91bmRDbGFzc2VzIGFuZCB0aGlzLmVtYmluZCBiYXNpY2FsbHkgYmUgdGhlIHNhbWUgZXhhY3QgdGhpbmcuXHJcbiAgICAgICAgRW1ib3VuZENsYXNzZXNbcmF3VHlwZV0gPSAodGhpcy5lbWJpbmQgYXMgYW55KVtuYW1lXSA9IHJlbmFtZUZ1bmN0aW9uKG5hbWUsXHJcbiAgICAgICAgICAgIC8vIFVubGlrZSB0aGUgY29uc3RydWN0b3IsIHRoZSBkZXN0cnVjdG9yIGlzIGtub3duIGVhcmx5IGVub3VnaCB0byBhc3NpZ24gbm93LlxyXG4gICAgICAgICAgICAvLyBQcm9iYWJseSBiZWNhdXNlIGRlc3RydWN0b3JzIGNhbid0IGJlIG92ZXJsb2FkZWQgYnkgYW55dGhpbmcgc28gdGhlcmUncyBvbmx5IGV2ZXIgb25lLlxyXG4gICAgICAgICAgICAvLyBBbnl3YXksIGFzc2lnbiBpdCB0byB0aGlzIG5ldyBjbGFzcy5cclxuICAgICAgICAgICAgY2xhc3MgZXh0ZW5kcyBFbWJvdW5kQ2xhc3Mge1xyXG4gICAgICAgICAgICAgICAgc3RhdGljIF9kZXN0cnVjdG9yID0gcmF3RGVzdHJ1Y3Rvckludm9rZXI7XHJcbiAgICAgICAgICAgIH0gYXMgYW55KTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZnJvbVdpcmVUeXBlKF90aGlzOiBudW1iZXIpOiBXaXJlQ29udmVyc2lvblJlc3VsdDxudW1iZXIsIEVtYm91bmRDbGFzcz4geyBjb25zdCBqc1ZhbHVlID0gbmV3IEVtYm91bmRDbGFzc2VzW3Jhd1R5cGVdKFNlY3JldCwgX3RoaXMpOyByZXR1cm4geyB3aXJlVmFsdWU6IF90aGlzLCBqc1ZhbHVlLCBzdGFja0Rlc3RydWN0b3I6ICgpID0+IGpzVmFsdWVbU3ltYm9sLmRpc3Bvc2VdKCkgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gdG9XaXJlVHlwZShqc09iamVjdDogRW1ib3VuZENsYXNzKTogV2lyZUNvbnZlcnNpb25SZXN1bHQ8bnVtYmVyLCBFbWJvdW5kQ2xhc3M+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHdpcmVWYWx1ZTogKGpzT2JqZWN0IGFzIGFueSkuX3RoaXMsXHJcbiAgICAgICAgICAgICAgICBqc1ZhbHVlOiBqc09iamVjdCxcclxuICAgICAgICAgICAgICAgIC8vIE5vdGU6IG5vIGRlc3RydWN0b3JzIGZvciBhbnkgb2YgdGhlc2UsXHJcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoZXkncmUganVzdCBmb3IgdmFsdWUtdHlwZXMtYXMtb2JqZWN0LXR5cGVzLlxyXG4gICAgICAgICAgICAgICAgLy8gQWRkaW5nIGl0IGhlcmUgd291bGRuJ3Qgd29yayBwcm9wZXJseSwgYmVjYXVzZSBpdCBhc3N1bWVzXHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBvd24gdGhlIG9iamVjdCAod2hlbiBjb252ZXJ0aW5nIGZyb20gYSBKUyBzdHJpbmcgdG8gc3RkOjpzdHJpbmcsIHdlIGVmZmVjdGl2ZWx5IGRvLCBidXQgbm90IGhlcmUpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBXaXNoIG90aGVyIHR5cGVzIGluY2x1ZGVkIHBvaW50ZXIgVHlwZUlEcyB3aXRoIHRoZW0gdG9vLi4uXHJcbiAgICAgICAgZmluYWxpemVUeXBlPG51bWJlciwgRW1ib3VuZENsYXNzPih0aGlzLCBuYW1lLCB7IHR5cGVJZDogcmF3VHlwZSwgZnJvbVdpcmVUeXBlLCB0b1dpcmVUeXBlIH0pO1xyXG4gICAgICAgIGZpbmFsaXplVHlwZTxudW1iZXIsIEVtYm91bmRDbGFzcz4odGhpcywgYCR7bmFtZX0qYCwgeyB0eXBlSWQ6IHJhd1BvaW50ZXJUeXBlLCBmcm9tV2lyZVR5cGUsIHRvV2lyZVR5cGUgfSk7XHJcbiAgICAgICAgZmluYWxpemVUeXBlPG51bWJlciwgRW1ib3VuZENsYXNzPih0aGlzLCBgJHtuYW1lfSBjb25zdCpgLCB7IHR5cGVJZDogcmF3Q29uc3RQb2ludGVyVHlwZSwgZnJvbVdpcmVUeXBlLCB0b1dpcmVUeXBlIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuIl19