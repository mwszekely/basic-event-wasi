import { renameFunction } from "../_private/embind/create-named-function.js";
import { EmboundClass, EmboundClasses, Secret } from "../_private/embind/embound-class.js";
import { finalizeType } from "../_private/embind/finalize.js";
import { getTableFunction } from "../_private/embind/get-table-function.js";
import { _embind_register } from "../_private/embind/register.js";
export { inspectClassByPointer } from "../_private/embind/embound-class.js";
export function _embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualTypePtr, upcastSignature, upcastPtr, downcastSignature, downcastPtr, namePtr, destructorSignature, rawDestructorPtr) {
    /**
     * Note: _embind_register_class doesn't have a corresponding `finalize` version,
     * like value_array and value_object have, which is fine I guess?
     *
     * But it means that we can't just create a class pre-installed with everything it needs--
     * we need to add member functions and properties and such as we get them, and we
     * never really know when we're done.
     */
    _embind_register(this, namePtr, async (name) => {
        const rawDestructorInvoker = getTableFunction(this, destructorSignature, rawDestructorPtr);
        // TODO(?) It's probably not necessary to have EmboundClasses and this.embind basically be the same exact thing.
        EmboundClasses[rawType] = this.embind[name] = renameFunction(name, 
        // Unlike the constructor, the destructor is known early enough to assign now.
        // Probably because destructors can't be overloaded by anything so there's only ever one.
        // Anyway, assign it to this new class.
        class extends EmboundClass {
            static _destructor = rawDestructorInvoker;
        });
        function fromWireType(_this) { const jsValue = new EmboundClasses[rawType](Secret, _this); return { wireValue: _this, jsValue, stackDestructor: () => jsValue[Symbol.dispose]() }; }
        function toWireType(jsObject) {
            return {
                wireValue: jsObject._this,
                jsValue: jsObject,
                // Note: no destructors for any of these,
                // because they're just for value-types-as-object-types.
                // Adding it here wouldn't work properly, because it assumes
                // we own the object (when converting from a JS string to std::string, we effectively do, but not here)
            };
        }
        // Wish other types included pointer TypeIDs with them too...
        finalizeType(this, name, { typeId: rawType, fromWireType, toWireType });
        finalizeType(this, `${name}*`, { typeId: rawPointerType, fromWireType, toWireType });
        finalizeType(this, `${name} const*`, { typeId: rawConstPointerType, fromWireType, toWireType });
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW1iaW5kX3JlZ2lzdGVyX2NsYXNzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2Vudi9lbWJpbmRfcmVnaXN0ZXJfY2xhc3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDZDQUE2QyxDQUFDO0FBQzdFLE9BQU8sRUFBRSxZQUFZLEVBQUUsY0FBYyxFQUFFLE1BQU0sRUFBRSxNQUFNLHFDQUFxQyxDQUFDO0FBQzNGLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUM5RCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSwwQ0FBMEMsQ0FBQztBQUM1RSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUdsRSxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUc1RSxNQUFNLFVBQVUsc0JBQXNCLENBRWxDLE9BQWUsRUFDZixjQUFzQixFQUN0QixtQkFBMkIsRUFDM0IsZ0JBQXdCLEVBQ3hCLHNCQUE4QixFQUM5QixnQkFBd0IsRUFDeEIsZUFBdUIsRUFDdkIsU0FBaUIsRUFDakIsaUJBQXlCLEVBQ3pCLFdBQW1CLEVBQ25CLE9BQWUsRUFDZixtQkFBMkIsRUFDM0IsZ0JBQXdCO0lBRXhCOzs7Ozs7O09BT0c7SUFFSCxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsRUFBRTtRQUMzQyxNQUFNLG9CQUFvQixHQUFHLGdCQUFnQixDQUEwQixJQUFJLEVBQUUsbUJBQW1CLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztRQUVwSCxnSEFBZ0g7UUFDaEgsY0FBYyxDQUFDLE9BQU8sQ0FBQyxHQUFJLElBQUksQ0FBQyxNQUFjLENBQUMsSUFBSSxDQUFDLEdBQUcsY0FBYyxDQUFDLElBQUk7UUFDdEUsOEVBQThFO1FBQzlFLHlGQUF5RjtRQUN6Rix1Q0FBdUM7UUFDdkMsS0FBTSxTQUFRLFlBQVk7WUFDdEIsTUFBTSxDQUFDLFdBQVcsR0FBRyxvQkFBb0IsQ0FBQztTQUN0QyxDQUFDLENBQUM7UUFFZCxTQUFTLFlBQVksQ0FBQyxLQUFhLElBQWdELE1BQU0sT0FBTyxHQUFHLElBQUksY0FBYyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxlQUFlLEVBQUUsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsRUFBRSxFQUFFLENBQUEsQ0FBQyxDQUFDO1FBQ3ZPLFNBQVMsVUFBVSxDQUFDLFFBQXNCO1lBQ3RDLE9BQU87Z0JBQ0gsU0FBUyxFQUFHLFFBQWdCLENBQUMsS0FBSztnQkFDbEMsT0FBTyxFQUFFLFFBQVE7Z0JBQ2pCLHlDQUF5QztnQkFDekMsd0RBQXdEO2dCQUN4RCw0REFBNEQ7Z0JBQzVELHVHQUF1RzthQUMxRyxDQUFDO1FBQ04sQ0FBQztRQUVELDZEQUE2RDtRQUM3RCxZQUFZLENBQXVCLElBQUksRUFBRSxJQUFJLEVBQUUsRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLFlBQVksRUFBRSxVQUFVLEVBQUUsQ0FBQyxDQUFDO1FBQzlGLFlBQVksQ0FBdUIsSUFBSSxFQUFFLEdBQUcsSUFBSSxHQUFHLEVBQUUsRUFBRSxNQUFNLEVBQUUsY0FBYyxFQUFFLFlBQVksRUFBRSxVQUFVLEVBQUUsQ0FBQyxDQUFDO1FBQzNHLFlBQVksQ0FBdUIsSUFBSSxFQUFFLEdBQUcsSUFBSSxTQUFTLEVBQUUsRUFBRSxNQUFNLEVBQUUsbUJBQW1CLEVBQUUsWUFBWSxFQUFFLFVBQVUsRUFBRSxDQUFDLENBQUM7SUFDMUgsQ0FBQyxDQUFDLENBQUM7QUFDUCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVuYW1lRnVuY3Rpb24gfSBmcm9tIFwiLi4vX3ByaXZhdGUvZW1iaW5kL2NyZWF0ZS1uYW1lZC1mdW5jdGlvbi5qc1wiO1xyXG5pbXBvcnQgeyBFbWJvdW5kQ2xhc3MsIEVtYm91bmRDbGFzc2VzLCBTZWNyZXQgfSBmcm9tIFwiLi4vX3ByaXZhdGUvZW1iaW5kL2VtYm91bmQtY2xhc3MuanNcIjtcclxuaW1wb3J0IHsgZmluYWxpemVUeXBlIH0gZnJvbSBcIi4uL19wcml2YXRlL2VtYmluZC9maW5hbGl6ZS5qc1wiO1xyXG5pbXBvcnQgeyBnZXRUYWJsZUZ1bmN0aW9uIH0gZnJvbSBcIi4uL19wcml2YXRlL2VtYmluZC9nZXQtdGFibGUtZnVuY3Rpb24uanNcIjtcclxuaW1wb3J0IHsgX2VtYmluZF9yZWdpc3RlciB9IGZyb20gXCIuLi9fcHJpdmF0ZS9lbWJpbmQvcmVnaXN0ZXIuanNcIjtcclxuaW1wb3J0IHsgV2lyZUNvbnZlcnNpb25SZXN1bHQgfSBmcm9tIFwiLi4vX3ByaXZhdGUvZW1iaW5kL3R5cGVzLmpzXCI7XHJcbmltcG9ydCB7IEluc3RhbnRpYXRlZFdhc2kgfSBmcm9tIFwiLi4vaW5zdGFudGlhdGVkLXdhc2kuanNcIjtcclxuZXhwb3J0IHsgaW5zcGVjdENsYXNzQnlQb2ludGVyIH0gZnJvbSBcIi4uL19wcml2YXRlL2VtYmluZC9lbWJvdW5kLWNsYXNzLmpzXCI7XHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9lbWJpbmRfcmVnaXN0ZXJfY2xhc3MoXHJcbiAgICB0aGlzOiBJbnN0YW50aWF0ZWRXYXNpPHt9PixcclxuICAgIHJhd1R5cGU6IG51bWJlcixcclxuICAgIHJhd1BvaW50ZXJUeXBlOiBudW1iZXIsXHJcbiAgICByYXdDb25zdFBvaW50ZXJUeXBlOiBudW1iZXIsXHJcbiAgICBiYXNlQ2xhc3NSYXdUeXBlOiBudW1iZXIsXHJcbiAgICBnZXRBY3R1YWxUeXBlU2lnbmF0dXJlOiBudW1iZXIsXHJcbiAgICBnZXRBY3R1YWxUeXBlUHRyOiBudW1iZXIsXHJcbiAgICB1cGNhc3RTaWduYXR1cmU6IG51bWJlcixcclxuICAgIHVwY2FzdFB0cjogbnVtYmVyLFxyXG4gICAgZG93bmNhc3RTaWduYXR1cmU6IG51bWJlcixcclxuICAgIGRvd25jYXN0UHRyOiBudW1iZXIsXHJcbiAgICBuYW1lUHRyOiBudW1iZXIsXHJcbiAgICBkZXN0cnVjdG9yU2lnbmF0dXJlOiBudW1iZXIsXHJcbiAgICByYXdEZXN0cnVjdG9yUHRyOiBudW1iZXIpOiB2b2lkIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vdGU6IF9lbWJpbmRfcmVnaXN0ZXJfY2xhc3MgZG9lc24ndCBoYXZlIGEgY29ycmVzcG9uZGluZyBgZmluYWxpemVgIHZlcnNpb24sXHJcbiAgICAgKiBsaWtlIHZhbHVlX2FycmF5IGFuZCB2YWx1ZV9vYmplY3QgaGF2ZSwgd2hpY2ggaXMgZmluZSBJIGd1ZXNzP1xyXG4gICAgICogXHJcbiAgICAgKiBCdXQgaXQgbWVhbnMgdGhhdCB3ZSBjYW4ndCBqdXN0IGNyZWF0ZSBhIGNsYXNzIHByZS1pbnN0YWxsZWQgd2l0aCBldmVyeXRoaW5nIGl0IG5lZWRzLS1cclxuICAgICAqIHdlIG5lZWQgdG8gYWRkIG1lbWJlciBmdW5jdGlvbnMgYW5kIHByb3BlcnRpZXMgYW5kIHN1Y2ggYXMgd2UgZ2V0IHRoZW0sIGFuZCB3ZVxyXG4gICAgICogbmV2ZXIgcmVhbGx5IGtub3cgd2hlbiB3ZSdyZSBkb25lLlxyXG4gICAgICovXHJcblxyXG4gICAgX2VtYmluZF9yZWdpc3Rlcih0aGlzLCBuYW1lUHRyLCBhc3luYyAobmFtZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJhd0Rlc3RydWN0b3JJbnZva2VyID0gZ2V0VGFibGVGdW5jdGlvbjwoX3RoaXM6IG51bWJlcikgPT4gdm9pZD4odGhpcywgZGVzdHJ1Y3RvclNpZ25hdHVyZSwgcmF3RGVzdHJ1Y3RvclB0cik7XHJcblxyXG4gICAgICAgIC8vIFRPRE8oPykgSXQncyBwcm9iYWJseSBub3QgbmVjZXNzYXJ5IHRvIGhhdmUgRW1ib3VuZENsYXNzZXMgYW5kIHRoaXMuZW1iaW5kIGJhc2ljYWxseSBiZSB0aGUgc2FtZSBleGFjdCB0aGluZy5cclxuICAgICAgICBFbWJvdW5kQ2xhc3Nlc1tyYXdUeXBlXSA9ICh0aGlzLmVtYmluZCBhcyBhbnkpW25hbWVdID0gcmVuYW1lRnVuY3Rpb24obmFtZSxcclxuICAgICAgICAgICAgLy8gVW5saWtlIHRoZSBjb25zdHJ1Y3RvciwgdGhlIGRlc3RydWN0b3IgaXMga25vd24gZWFybHkgZW5vdWdoIHRvIGFzc2lnbiBub3cuXHJcbiAgICAgICAgICAgIC8vIFByb2JhYmx5IGJlY2F1c2UgZGVzdHJ1Y3RvcnMgY2FuJ3QgYmUgb3ZlcmxvYWRlZCBieSBhbnl0aGluZyBzbyB0aGVyZSdzIG9ubHkgZXZlciBvbmUuXHJcbiAgICAgICAgICAgIC8vIEFueXdheSwgYXNzaWduIGl0IHRvIHRoaXMgbmV3IGNsYXNzLlxyXG4gICAgICAgICAgICBjbGFzcyBleHRlbmRzIEVtYm91bmRDbGFzcyB7XHJcbiAgICAgICAgICAgICAgICBzdGF0aWMgX2Rlc3RydWN0b3IgPSByYXdEZXN0cnVjdG9ySW52b2tlcjtcclxuICAgICAgICAgICAgfSBhcyBhbnkpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBmcm9tV2lyZVR5cGUoX3RoaXM6IG51bWJlcik6IFdpcmVDb252ZXJzaW9uUmVzdWx0PG51bWJlciwgRW1ib3VuZENsYXNzPiB7IGNvbnN0IGpzVmFsdWUgPSBuZXcgRW1ib3VuZENsYXNzZXNbcmF3VHlwZV0oU2VjcmV0LCBfdGhpcyk7IHJldHVybiB7IHdpcmVWYWx1ZTogX3RoaXMsIGpzVmFsdWUsIHN0YWNrRGVzdHJ1Y3RvcjogKCkgPT4ganNWYWx1ZVtTeW1ib2wuZGlzcG9zZV0oKSB9IH1cclxuICAgICAgICBmdW5jdGlvbiB0b1dpcmVUeXBlKGpzT2JqZWN0OiBFbWJvdW5kQ2xhc3MpOiBXaXJlQ29udmVyc2lvblJlc3VsdDxudW1iZXIsIEVtYm91bmRDbGFzcz4ge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgd2lyZVZhbHVlOiAoanNPYmplY3QgYXMgYW55KS5fdGhpcyxcclxuICAgICAgICAgICAgICAgIGpzVmFsdWU6IGpzT2JqZWN0LFxyXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogbm8gZGVzdHJ1Y3RvcnMgZm9yIGFueSBvZiB0aGVzZSxcclxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhleSdyZSBqdXN0IGZvciB2YWx1ZS10eXBlcy1hcy1vYmplY3QtdHlwZXMuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGRpbmcgaXQgaGVyZSB3b3VsZG4ndCB3b3JrIHByb3Blcmx5LCBiZWNhdXNlIGl0IGFzc3VtZXNcclxuICAgICAgICAgICAgICAgIC8vIHdlIG93biB0aGUgb2JqZWN0ICh3aGVuIGNvbnZlcnRpbmcgZnJvbSBhIEpTIHN0cmluZyB0byBzdGQ6OnN0cmluZywgd2UgZWZmZWN0aXZlbHkgZG8sIGJ1dCBub3QgaGVyZSlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFdpc2ggb3RoZXIgdHlwZXMgaW5jbHVkZWQgcG9pbnRlciBUeXBlSURzIHdpdGggdGhlbSB0b28uLi5cclxuICAgICAgICBmaW5hbGl6ZVR5cGU8bnVtYmVyLCBFbWJvdW5kQ2xhc3M+KHRoaXMsIG5hbWUsIHsgdHlwZUlkOiByYXdUeXBlLCBmcm9tV2lyZVR5cGUsIHRvV2lyZVR5cGUgfSk7XHJcbiAgICAgICAgZmluYWxpemVUeXBlPG51bWJlciwgRW1ib3VuZENsYXNzPih0aGlzLCBgJHtuYW1lfSpgLCB7IHR5cGVJZDogcmF3UG9pbnRlclR5cGUsIGZyb21XaXJlVHlwZSwgdG9XaXJlVHlwZSB9KTtcclxuICAgICAgICBmaW5hbGl6ZVR5cGU8bnVtYmVyLCBFbWJvdW5kQ2xhc3M+KHRoaXMsIGAke25hbWV9IGNvbnN0KmAsIHsgdHlwZUlkOiByYXdDb25zdFBvaW50ZXJUeXBlLCBmcm9tV2lyZVR5cGUsIHRvV2lyZVR5cGUgfSk7XHJcbiAgICB9KTtcclxufVxyXG4iXX0=