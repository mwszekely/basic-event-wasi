import { awaitAllEmbind } from "./_private/embind/register.js";
import {} from "./types.js";
//  This reassignment is a Typescript hack to add custom types to addEventListener...
const EventTargetW = EventTarget;
/**
 * Extension of `WebAssembly.WebAssemblyInstantiatedSource` that is also an `EventTarget` for all WASI "event"s (which, yes, is why this is an entire `class`).
 */
export class InstantiatedWasm extends EventTargetW {
    /** The `WebAssembly.Module` this instance was built from. Rarely useful by itself. */
    module;
    /** The `WebAssembly.Module` this instance was built from. Rarely useful by itself. */
    instance;
    /**
     * Contains everything exported using embind.
     *
     * These are separate from regular exports on `instance.export`.
     */
    embind;
    /**
     * The "raw" WASM exports. None are prefixed with "_".
     *
     * No conversion is performed on the types here; everything takes or returns a number.
     *
     */
    exports;
    /**
     * `exports.memory`, but updated when/if more memory is allocated.
     *
     * Generally speaking, it's more convenient to use the general-purpose `readUint32` functions,
     * since they account for `DataView` being big-endian by default.
     */
    cachedMemoryView;
    /**
     * Not intended to be called directly. Use the static `instantiate` function instead, which returns one of these.
     *
     * I want to instead just return a promise here sooooooo badly...
     */
    constructor() {
        super();
        this.module = this.instance = this.exports = this.cachedMemoryView = null;
        this.embind = {};
    }
    static async instantiate(wasmDataOrFetcher, { wasi_snapshot_preview1, env, ...unboundImports }) {
        // (These are just up here to not get in the way of the comments)
        let wasm;
        let module;
        let instance;
        // There's a bit of song and dance to get around the fact that:
        // 1. WASM needs its WASI imports immediately upon instantiation.
        // 2. WASI needs its WASM `Instance` in order to function.
        // First, bind all of our imports to the same object, 
        // which also happens to be the InstantiatedWasm we're returning (but could theoretically be something else).
        // This is how they'll be able to access memory and communicate with each other.
        wasm = new InstantiatedWasm();
        const imports = {
            wasi_snapshot_preview1: bindAllFuncs(wasm, wasi_snapshot_preview1),
            env: bindAllFuncs(wasm, env),
            ...unboundImports
        };
        // We have those imports, and they've been bound to the to-be-instantiated WASM.
        // Now pass those bound imports to WebAssembly.instantiate (or whatever the user specified)
        if (wasmDataOrFetcher instanceof WebAssembly.Module) {
            instance = await WebAssembly.instantiate(wasmDataOrFetcher, imports);
            module = wasmDataOrFetcher;
        }
        else if (wasmDataOrFetcher instanceof ArrayBuffer || ArrayBuffer.isView(wasmDataOrFetcher))
            ({ instance, module } = await WebAssembly.instantiate(wasmDataOrFetcher, imports));
        else if (isResponse(wasmDataOrFetcher))
            ({ instance, module } = await WebAssembly.instantiateStreaming(wasmDataOrFetcher, imports));
        else
            ({ instance, module } = await wasmDataOrFetcher(imports));
        // Do the stuff we couldn't do in the `InstantiatedWasm` constructor because we didn't have these then:
        wasm.instance = instance;
        wasm.module = module;
        wasm.exports = wasm.instance.exports;
        wasm.cachedMemoryView = new DataView(wasm.exports.memory.buffer);
        // Almost done -- now run WASI's `_start` or `_initialize` function.
        console.assert(("_initialize" in wasm.instance.exports) != "_start" in wasm.instance.exports, `Expected either _initialize XOR _start to be exported from this WASM.`);
        if ("_initialize" in wasm.instance.exports)
            wasm.instance.exports._initialize();
        else if ("_start" in wasm.instance.exports)
            wasm.instance.exports._start();
        // Wait for all Embind calls to resolve (they `await` each other based on the dependencies they need, and this resolves when all dependencies have too)
        await awaitAllEmbind();
        // And we're finally finished.
        return wasm;
    }
}
// Given an object, binds each function in that object to p (shallowly).
function bindAllFuncs(p, r) {
    return Object.fromEntries(Object.entries(r).map(([key, func]) => { return [key, (typeof func == "function" ? func.bind(p) : func)]; }));
}
// Separated out for type reasons due to "Response" not existing in limited Worklet-like environments.
function isResponse(arg) { return "then" in arg || ("Response" in globalThis && arg instanceof Response); }
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2FzbS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy93YXNtLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUUvRCxPQUFPLEVBQXdDLE1BQU0sWUFBWSxDQUFDO0FBYWxFLHFGQUFxRjtBQUNyRixNQUFNLFlBQVksR0FBRyxXQUE2RixDQUFDO0FBRW5IOztHQUVHO0FBQ0gsTUFBTSxPQUFPLGdCQUFrRSxTQUFRLFlBQVk7SUFDL0Ysc0ZBQXNGO0lBQy9FLE1BQU0sQ0FBcUI7SUFFbEMsc0ZBQXNGO0lBQy9FLFFBQVEsQ0FBdUI7SUFFdEM7Ozs7T0FJRztJQUNJLE1BQU0sQ0FBUztJQUV0Qjs7Ozs7T0FLRztJQUNJLE9BQU8sQ0FBeUI7SUFFdkM7Ozs7O09BS0c7SUFDSSxnQkFBZ0IsQ0FBVztJQUVsQzs7OztPQUlHO0lBQ0g7UUFDSSxLQUFLLEVBQUUsQ0FBQztRQUNSLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFLLENBQUE7UUFDMUUsSUFBSSxDQUFDLE1BQU0sR0FBRyxFQUFXLENBQUM7SUFDOUIsQ0FBQztJQWtCRCxNQUFNLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBd0MsaUJBQTJHLEVBQUUsRUFBRSxzQkFBc0IsRUFBRSxHQUFHLEVBQUUsR0FBRyxjQUFjLEVBQWdCO1FBQ3pPLGlFQUFpRTtRQUNqRSxJQUFJLElBQXVDLENBQUM7UUFDNUMsSUFBSSxNQUEwQixDQUFDO1FBQy9CLElBQUksUUFBOEIsQ0FBQztRQUduQywrREFBK0Q7UUFDL0QsaUVBQWlFO1FBQ2pFLDBEQUEwRDtRQUUxRCxzREFBc0Q7UUFDdEQsNkdBQTZHO1FBQzdHLGdGQUFnRjtRQUNoRixJQUFJLEdBQUcsSUFBSSxnQkFBZ0IsRUFBbUIsQ0FBQztRQUMvQyxNQUFNLE9BQU8s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Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXdhaXRBbGxFbWJpbmQgfSBmcm9tIFwiLi9fcHJpdmF0ZS9lbWJpbmQvcmVnaXN0ZXIuanNcIjtcclxuaW1wb3J0IHR5cGUgeyBFdmVudFR5cGVzTWFwIH0gZnJvbSBcIi4vX3ByaXZhdGUvZXZlbnQtdHlwZXMtbWFwLmpzXCI7XHJcbmltcG9ydCB7IHR5cGUgS25vd25FeHBvcnRzLCB0eXBlIEtub3duSW1wb3J0cyB9IGZyb20gXCIuL3R5cGVzLmpzXCI7XHJcblxyXG5cclxuZXhwb3J0IHR5cGUgUm9sbHVwV2FzbVByb21pc2U8SSBleHRlbmRzIEtub3duSW1wb3J0cyA9IEtub3duSW1wb3J0cz4gPSAoaW1wb3J0cz86IEkpID0+IFByb21pc2U8V2ViQXNzZW1ibHkuV2ViQXNzZW1ibHlJbnN0YW50aWF0ZWRTb3VyY2U+O1xyXG5cclxuXHJcblxyXG5pbnRlcmZhY2UgSW5zdGFudGlhdGVkV2FzbUV2ZW50VGFyZ2V0IGV4dGVuZHMgRXZlbnRUYXJnZXQge1xyXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjxLIGV4dGVuZHMga2V5b2YgRXZlbnRUeXBlc01hcD4odHlwZTogSywgbGlzdGVuZXI6ICh0aGlzOiBGaWxlUmVhZGVyLCBldjogRXZlbnRUeXBlc01hcFtLXSkgPT4gYW55LCBvcHRpb25zPzogYm9vbGVhbiB8IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKTogdm9pZDtcclxuICAgIGFkZEV2ZW50TGlzdGVuZXIodHlwZTogc3RyaW5nLCBjYWxsYmFjazogRXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdCB8IG51bGwsIG9wdGlvbnM/OiBFdmVudExpc3RlbmVyT3B0aW9ucyB8IGJvb2xlYW4pOiB2b2lkO1xyXG59XHJcblxyXG5cclxuLy8gIFRoaXMgcmVhc3NpZ25tZW50IGlzIGEgVHlwZXNjcmlwdCBoYWNrIHRvIGFkZCBjdXN0b20gdHlwZXMgdG8gYWRkRXZlbnRMaXN0ZW5lci4uLlxyXG5jb25zdCBFdmVudFRhcmdldFcgPSBFdmVudFRhcmdldCBhcyB7IG5ldygpOiBJbnN0YW50aWF0ZWRXYXNtRXZlbnRUYXJnZXQ7IHByb3RvdHlwZTogSW5zdGFudGlhdGVkV2FzbUV2ZW50VGFyZ2V0IH07XHJcblxyXG4vKipcclxuICogRXh0ZW5zaW9uIG9mIGBXZWJBc3NlbWJseS5XZWJBc3NlbWJseUluc3RhbnRpYXRlZFNvdXJjZWAgdGhhdCBpcyBhbHNvIGFuIGBFdmVudFRhcmdldGAgZm9yIGFsbCBXQVNJIFwiZXZlbnRcInMgKHdoaWNoLCB5ZXMsIGlzIHdoeSB0aGlzIGlzIGFuIGVudGlyZSBgY2xhc3NgKS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBJbnN0YW50aWF0ZWRXYXNtPEV4cG9ydHMgZXh0ZW5kcyB7fSA9IHt9LCBFbWJpbmQgZXh0ZW5kcyB7fSA9IHt9PiBleHRlbmRzIEV2ZW50VGFyZ2V0VyBpbXBsZW1lbnRzIFdlYkFzc2VtYmx5LldlYkFzc2VtYmx5SW5zdGFudGlhdGVkU291cmNlIHtcclxuICAgIC8qKiBUaGUgYFdlYkFzc2VtYmx5Lk1vZHVsZWAgdGhpcyBpbnN0YW5jZSB3YXMgYnVpbHQgZnJvbS4gUmFyZWx5IHVzZWZ1bCBieSBpdHNlbGYuICovXHJcbiAgICBwdWJsaWMgbW9kdWxlOiBXZWJBc3NlbWJseS5Nb2R1bGU7XHJcblxyXG4gICAgLyoqIFRoZSBgV2ViQXNzZW1ibHkuTW9kdWxlYCB0aGlzIGluc3RhbmNlIHdhcyBidWlsdCBmcm9tLiBSYXJlbHkgdXNlZnVsIGJ5IGl0c2VsZi4gKi9cclxuICAgIHB1YmxpYyBpbnN0YW5jZTogV2ViQXNzZW1ibHkuSW5zdGFuY2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb250YWlucyBldmVyeXRoaW5nIGV4cG9ydGVkIHVzaW5nIGVtYmluZC5cclxuICAgICAqIFxyXG4gICAgICogVGhlc2UgYXJlIHNlcGFyYXRlIGZyb20gcmVndWxhciBleHBvcnRzIG9uIGBpbnN0YW5jZS5leHBvcnRgLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZW1iaW5kOiBFbWJpbmQ7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogVGhlIFwicmF3XCIgV0FTTSBleHBvcnRzLiBOb25lIGFyZSBwcmVmaXhlZCB3aXRoIFwiX1wiLlxyXG4gICAgICogXHJcbiAgICAgKiBObyBjb252ZXJzaW9uIGlzIHBlcmZvcm1lZCBvbiB0aGUgdHlwZXMgaGVyZTsgZXZlcnl0aGluZyB0YWtlcyBvciByZXR1cm5zIGEgbnVtYmVyLlxyXG4gICAgICogXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBleHBvcnRzOiBFeHBvcnRzICYgS25vd25FeHBvcnRzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogYGV4cG9ydHMubWVtb3J5YCwgYnV0IHVwZGF0ZWQgd2hlbi9pZiBtb3JlIG1lbW9yeSBpcyBhbGxvY2F0ZWQuXHJcbiAgICAgKiBcclxuICAgICAqIEdlbmVyYWxseSBzcGVha2luZywgaXQncyBtb3JlIGNvbnZlbmllbnQgdG8gdXNlIHRoZSBnZW5lcmFsLXB1cnBvc2UgYHJlYWRVaW50MzJgIGZ1bmN0aW9ucyxcclxuICAgICAqIHNpbmNlIHRoZXkgYWNjb3VudCBmb3IgYERhdGFWaWV3YCBiZWluZyBiaWctZW5kaWFuIGJ5IGRlZmF1bHQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjYWNoZWRNZW1vcnlWaWV3OiBEYXRhVmlldztcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBOb3QgaW50ZW5kZWQgdG8gYmUgY2FsbGVkIGRpcmVjdGx5LiBVc2UgdGhlIHN0YXRpYyBgaW5zdGFudGlhdGVgIGZ1bmN0aW9uIGluc3RlYWQsIHdoaWNoIHJldHVybnMgb25lIG9mIHRoZXNlLlxyXG4gICAgICogXHJcbiAgICAgKiBJIHdhbnQgdG8gaW5zdGVhZCBqdXN0IHJldHVybiBhIHByb21pc2UgaGVyZSBzb29vb29vbyBiYWRseS4uLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5tb2R1bGUgPSB0aGlzLmluc3RhbmNlID0gdGhpcy5leHBvcnRzID0gdGhpcy5jYWNoZWRNZW1vcnlWaWV3ID0gbnVsbCFcclxuICAgICAgICB0aGlzLmVtYmluZCA9IHt9IGFzIG5ldmVyO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc3RhbnRpYXRlcyBhIFdBU00gbW9kdWxlIHdpdGggdGhlIHNwZWNpZmllZCBXQVNJIGltcG9ydHMuXHJcbiAgICAgKiBcclxuICAgICAqIGBpbnB1dGAgY2FuIGJlIGFueSBvbmUgb2Y6XHJcbiAgICAgKiBcclxuICAgICAqICogYFJlc3BvbnNlYCBvciBgUHJvbWlzZTxSZXNwb25zZT5gIChmcm9tIGUuZy4gYGZldGNoYCkuIFVzZXMgYFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nYC5cclxuICAgICAqICogYEFycmF5QnVmZmVyYCByZXByZXNlbnRpbmcgdGhlIFdBU00gaW4gYmluYXJ5IGZvcm0sIG9yIGEgYFdlYkFzc2VtYmx5Lk1vZHVsZWAuIFxyXG4gICAgICogKiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgMSBhcmd1bWVudCBvZiB0eXBlIGBXZWJBc3NlbWJseS5JbXBvcnRzYCBhbmQgcmV0dXJucyBhIGBXZWJBc3NlbWJseS5XZWJBc3NlbWJseUluc3RhbnRpYXRlZFNvdXJjZWAuIFRoaXMgaXMgdGhlIHR5cGUgdGhhdCBgQHJvbGx1cC9wbHVnaW4td2FzbWAgcmV0dXJucyB3aGVuIGJ1bmRsaW5nIGEgcHJlLWJ1aWx0IFdBU00gYmluYXJ5LlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0gd2FzbUZldGNoUHJvbWlzZSBcclxuICAgICAqIEBwYXJhbSB1bmJvdW5kSW1wb3J0cyBcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGFzeW5jIGluc3RhbnRpYXRlPEV4cG9ydHMgZXh0ZW5kcyB7fSwgRW1iaW5kIGV4dGVuZHMge30+KHdhc21GZXRjaFByb21pc2U6IFJlc3BvbnNlIHwgUHJvbWlzZUxpa2U8UmVzcG9uc2U+LCB1bmJvdW5kSW1wb3J0czogS25vd25JbXBvcnRzKTogUHJvbWlzZTxJbnN0YW50aWF0ZWRXYXNtPEV4cG9ydHMsIEVtYmluZD4+O1xyXG4gICAgc3RhdGljIGFzeW5jIGluc3RhbnRpYXRlPEV4cG9ydHMgZXh0ZW5kcyB7fSwgRW1iaW5kIGV4dGVuZHMge30+KG1vZHVsZUJ5dGVzOiBXZWJBc3NlbWJseS5Nb2R1bGUgfCBCdWZmZXJTb3VyY2UsIHVuYm91bmRJbXBvcnRzOiBLbm93bkltcG9ydHMpOiBQcm9taXNlPEluc3RhbnRpYXRlZFdhc208RXhwb3J0cywgRW1iaW5kPj47XHJcbiAgICBzdGF0aWMgYXN5bmMgaW5zdGFudGlhdGU8RXhwb3J0cyBleHRlbmRzIHt9LCBFbWJpbmQgZXh0ZW5kcyB7fT4od2FzbUluc3RhbnRpYXRvcjogUm9sbHVwV2FzbVByb21pc2UsIHVuYm91bmRJbXBvcnRzOiBLbm93bkltcG9ydHMpOiBQcm9taXNlPEluc3RhbnRpYXRlZFdhc208RXhwb3J0cywgRW1iaW5kPj47XHJcbiAgICBzdGF0aWMgYXN5bmMgaW5zdGFudGlhdGU8RXhwb3J0cyBleHRlbmRzIHt9LCBFbWJpbmQgZXh0ZW5kcyB7fT4od2FzbURhdGFPckZldGNoZXI6IFJvbGx1cFdhc21Qcm9taXNlIHwgV2ViQXNzZW1ibHkuTW9kdWxlIHwgQnVmZmVyU291cmNlIHwgUmVzcG9uc2UgfCBQcm9taXNlTGlrZTxSZXNwb25zZT4sIHsgd2FzaV9zbmFwc2hvdF9wcmV2aWV3MSwgZW52LCAuLi51bmJvdW5kSW1wb3J0cyB9OiBLbm93bkltcG9ydHMpOiBQcm9taXNlPEluc3RhbnRpYXRlZFdhc208RXhwb3J0cywgRW1iaW5kPj4ge1xyXG4gICAgICAgIC8vIChUaGVzZSBhcmUganVzdCB1cCBoZXJlIHRvIG5vdCBnZXQgaW4gdGhlIHdheSBvZiB0aGUgY29tbWVudHMpXHJcbiAgICAgICAgbGV0IHdhc206IEluc3RhbnRpYXRlZFdhc208RXhwb3J0cywgRW1iaW5kPjtcclxuICAgICAgICBsZXQgbW9kdWxlOiBXZWJBc3NlbWJseS5Nb2R1bGU7XHJcbiAgICAgICAgbGV0IGluc3RhbmNlOiBXZWJBc3NlbWJseS5JbnN0YW5jZTtcclxuXHJcblxyXG4gICAgICAgIC8vIFRoZXJlJ3MgYSBiaXQgb2Ygc29uZyBhbmQgZGFuY2UgdG8gZ2V0IGFyb3VuZCB0aGUgZmFjdCB0aGF0OlxyXG4gICAgICAgIC8vIDEuIFdBU00gbmVlZHMgaXRzIFdBU0kgaW1wb3J0cyBpbW1lZGlhdGVseSB1cG9uIGluc3RhbnRpYXRpb24uXHJcbiAgICAgICAgLy8gMi4gV0FTSSBuZWVkcyBpdHMgV0FTTSBgSW5zdGFuY2VgIGluIG9yZGVyIHRvIGZ1bmN0aW9uLlxyXG5cclxuICAgICAgICAvLyBGaXJzdCwgYmluZCBhbGwgb2Ygb3VyIGltcG9ydHMgdG8gdGhlIHNhbWUgb2JqZWN0LCBcclxuICAgICAgICAvLyB3aGljaCBhbHNvIGhhcHBlbnMgdG8gYmUgdGhlIEluc3RhbnRpYXRlZFdhc20gd2UncmUgcmV0dXJuaW5nIChidXQgY291bGQgdGhlb3JldGljYWxseSBiZSBzb21ldGhpbmcgZWxzZSkuXHJcbiAgICAgICAgLy8gVGhpcyBpcyBob3cgdGhleSdsbCBiZSBhYmxlIHRvIGFjY2VzcyBtZW1vcnkgYW5kIGNvbW11bmljYXRlIHdpdGggZWFjaCBvdGhlci5cclxuICAgICAgICB3YXNtID0gbmV3IEluc3RhbnRpYXRlZFdhc208RXhwb3J0cywgRW1iaW5kPigpO1xyXG4gICAgICAgIGNvbnN0IGltcG9ydHMgPSB7XHJcbiAgICAgICAgICAgIHdhc2lfc25hcHNob3RfcHJldmlldzE6IGJpbmRBbGxGdW5jcyh3YXNtLCB3YXNpX3NuYXBzaG90X3ByZXZpZXcxKSxcclxuICAgICAgICAgICAgZW52OiBiaW5kQWxsRnVuY3Mod2FzbSwgZW52KSxcclxuICAgICAgICAgICAgLi4udW5ib3VuZEltcG9ydHNcclxuICAgICAgICB9IGFzIEtub3duSW1wb3J0cyAmIFdlYkFzc2VtYmx5LkltcG9ydHM7XHJcblxyXG4gICAgICAgIC8vIFdlIGhhdmUgdGhvc2UgaW1wb3J0cywgYW5kIHRoZXkndmUgYmVlbiBib3VuZCB0byB0aGUgdG8tYmUtaW5zdGFudGlhdGVkIFdBU00uXHJcbiAgICAgICAgLy8gTm93IHBhc3MgdGhvc2UgYm91bmQgaW1wb3J0cyB0byBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZSAob3Igd2hhdGV2ZXIgdGhlIHVzZXIgc3BlY2lmaWVkKVxyXG4gICAgICAgIGlmICh3YXNtRGF0YU9yRmV0Y2hlciBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lk1vZHVsZSkge1xyXG4gICAgICAgICAgICBpbnN0YW5jZSA9IGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHdhc21EYXRhT3JGZXRjaGVyLCBpbXBvcnRzKVxyXG4gICAgICAgICAgICBtb2R1bGUgPSB3YXNtRGF0YU9yRmV0Y2hlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAod2FzbURhdGFPckZldGNoZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcod2FzbURhdGFPckZldGNoZXIpKVxyXG4gICAgICAgICAgICAoeyBpbnN0YW5jZSwgbW9kdWxlIH0gPSBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZSh3YXNtRGF0YU9yRmV0Y2hlciwgaW1wb3J0cykpO1xyXG4gICAgICAgIGVsc2UgaWYgKGlzUmVzcG9uc2Uod2FzbURhdGFPckZldGNoZXIpKVxyXG4gICAgICAgICAgICAoeyBpbnN0YW5jZSwgbW9kdWxlIH0gPSBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyh3YXNtRGF0YU9yRmV0Y2hlciwgaW1wb3J0cykpO1xyXG5cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICh7IGluc3RhbmNlLCBtb2R1bGUgfSA9IGF3YWl0IHdhc21EYXRhT3JGZXRjaGVyKGltcG9ydHMpKTtcclxuXHJcblxyXG4gICAgICAgIC8vIERvIHRoZSBzdHVmZiB3ZSBjb3VsZG4ndCBkbyBpbiB0aGUgYEluc3RhbnRpYXRlZFdhc21gIGNvbnN0cnVjdG9yIGJlY2F1c2Ugd2UgZGlkbid0IGhhdmUgdGhlc2UgdGhlbjpcclxuICAgICAgICB3YXNtLmluc3RhbmNlID0gaW5zdGFuY2U7XHJcbiAgICAgICAgd2FzbS5tb2R1bGUgPSBtb2R1bGU7XHJcbiAgICAgICAgd2FzbS5leHBvcnRzID0gd2FzbS5pbnN0YW5jZS5leHBvcnRzIGFzIEV4cG9ydHMgYXMgRXhwb3J0cyAmIEtub3duRXhwb3J0cztcclxuICAgICAgICB3YXNtLmNhY2hlZE1lbW9yeVZpZXcgPSBuZXcgRGF0YVZpZXcod2FzbS5leHBvcnRzLm1lbW9yeS5idWZmZXIpO1xyXG5cclxuICAgICAgICAvLyBBbG1vc3QgZG9uZSAtLSBub3cgcnVuIFdBU0kncyBgX3N0YXJ0YCBvciBgX2luaXRpYWxpemVgIGZ1bmN0aW9uLlxyXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KChcIl9pbml0aWFsaXplXCIgaW4gd2FzbS5pbnN0YW5jZS5leHBvcnRzKSAhPSBcIl9zdGFydFwiIGluIHdhc20uaW5zdGFuY2UuZXhwb3J0cywgYEV4cGVjdGVkIGVpdGhlciBfaW5pdGlhbGl6ZSBYT1IgX3N0YXJ0IHRvIGJlIGV4cG9ydGVkIGZyb20gdGhpcyBXQVNNLmApO1xyXG4gICAgICAgIGlmIChcIl9pbml0aWFsaXplXCIgaW4gd2FzbS5pbnN0YW5jZS5leHBvcnRzKVxyXG4gICAgICAgICAgICAod2FzbS5pbnN0YW5jZS5leHBvcnRzIGFzIGFueSkuX2luaXRpYWxpemUoKTtcclxuICAgICAgICBlbHNlIGlmIChcIl9zdGFydFwiIGluIHdhc20uaW5zdGFuY2UuZXhwb3J0cylcclxuICAgICAgICAgICAgKHdhc20uaW5zdGFuY2UuZXhwb3J0cyBhcyBhbnkpLl9zdGFydCgpO1xyXG5cclxuICAgICAgICAvLyBXYWl0IGZvciBhbGwgRW1iaW5kIGNhbGxzIHRvIHJlc29sdmUgKHRoZXkgYGF3YWl0YCBlYWNoIG90aGVyIGJhc2VkIG9uIHRoZSBkZXBlbmRlbmNpZXMgdGhleSBuZWVkLCBhbmQgdGhpcyByZXNvbHZlcyB3aGVuIGFsbCBkZXBlbmRlbmNpZXMgaGF2ZSB0b28pXHJcbiAgICAgICAgYXdhaXQgYXdhaXRBbGxFbWJpbmQoKTtcclxuXHJcbiAgICAgICAgLy8gQW5kIHdlJ3JlIGZpbmFsbHkgZmluaXNoZWQuXHJcbiAgICAgICAgcmV0dXJuIHdhc207XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vIEdpdmVuIGFuIG9iamVjdCwgYmluZHMgZWFjaCBmdW5jdGlvbiBpbiB0aGF0IG9iamVjdCB0byBwIChzaGFsbG93bHkpLlxyXG5mdW5jdGlvbiBiaW5kQWxsRnVuY3M8UiBleHRlbmRzIHt9PihwOiBJbnN0YW50aWF0ZWRXYXNtLCByOiBSKTogUiB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHIpLm1hcCgoW2tleSwgZnVuY10pID0+IHsgcmV0dXJuIFtrZXksICh0eXBlb2YgZnVuYyA9PSBcImZ1bmN0aW9uXCIgPyBmdW5jLmJpbmQocCkgOiBmdW5jKV0gYXMgY29uc3Q7IH0pKSBhcyBSO1xyXG59XHJcblxyXG4vLyBTZXBhcmF0ZWQgb3V0IGZvciB0eXBlIHJlYXNvbnMgZHVlIHRvIFwiUmVzcG9uc2VcIiBub3QgZXhpc3RpbmcgaW4gbGltaXRlZCBXb3JrbGV0LWxpa2UgZW52aXJvbm1lbnRzLlxyXG5mdW5jdGlvbiBpc1Jlc3BvbnNlKGFyZzogYW55KTogYXJnIGlzIFJlc3BvbnNlIHwgUHJvbWlzZUxpa2U8UmVzcG9uc2U+IHsgcmV0dXJuIFwidGhlblwiIGluIGFyZyB8fCAoXCJSZXNwb25zZVwiIGluIGdsb2JhbFRoaXMgJiYgYXJnIGluc3RhbmNlb2YgUmVzcG9uc2UpOyB9XHJcblxyXG4iXX0=