import { awaitAllEmbind } from "./_private/embind/register.js";
import {} from "./types.js";
//  This reassignment is a Typescript hack to add custom types to addEventListener...
const EventTargetW = EventTarget;
/**
 * Extension of `WebAssembly.WebAssemblyInstantiatedSource` that is also an `EventTarget` for all WASI "event"s (which, yes, is why this is an entire `class`).
 */
export class InstantiatedWasm extends EventTargetW {
    /** The `WebAssembly.Module` this instance was built from. Rarely useful by itself. */
    module;
    /** The `WebAssembly.Module` this instance was built from. Rarely useful by itself. */
    instance;
    /**
     * Contains everything exported using embind.
     *
     * These are separate from regular exports on `instance.export`.
     */
    embind;
    /**
     * The "raw" WASM exports. None are prefixed with "_".
     *
     * No conversion is performed on the types here; everything takes or returns a number.
     *
     */
    exports;
    /**
     * `exports.memory`, but updated when/if more memory is allocated.
     *
     * Generally speaking, it's more convenient to use the general-purpose `readUint32` functions,
     * since they account for `DataView` being big-endian by default.
     */
    cachedMemoryView;
    /**
     * **IMPORTANT**: Until `initialize` is called, no WASM-related methods/fields can be used.
     *
     * `addEventListener` and other `EventTarget` methods are fine, though, and in fact are required for events that occur during `_initialize` or `_start`.
     *
     * If you don't care about events during initialization, you can also just call `InstantiatedWasm.instantiate`, which is an async function that does both in one step.
     */
    constructor() {
        super();
        this.module = this.instance = this.exports = this.cachedMemoryView = null;
        this.embind = {};
    }
    /**
     * Instantiates a WASM module with the specified WASI imports.
     *
     * `input` can be any one of:
     *
     * * `Response` or `Promise<Response>` (from e.g. `fetch`). Uses `WebAssembly.instantiateStreaming`.
     * * `ArrayBuffer` representing the WASM in binary form, or a `WebAssembly.Module`.
     * * A function that takes 1 argument of type `WebAssembly.Imports` and returns a `WebAssembly.WebAssemblyInstantiatedSource`. This is the type that `@rollup/plugin-wasm` returns when bundling a pre-built WASM binary.
     *
     * @param wasmFetchPromise
     * @param unboundImports
     */
    async instantiate(wasmDataOrFetcher, { wasi_snapshot_preview1, env, ...unboundImports }) {
        // (These are just up here to not get in the way of the comments)
        let module;
        let instance;
        // There's a bit of song and dance to get around the fact that:
        // 1. WASM needs its WASI imports immediately upon instantiation.
        // 2. WASI needs its WASM `Instance` in order to function.
        // First, bind all of our imports to the same object, 
        // which also happens to be the InstantiatedWasm we're returning (but could theoretically be something else).
        // This is how they'll be able to access memory and communicate with each other.
        const imports = {
            wasi_snapshot_preview1: bindAllFuncs(this, wasi_snapshot_preview1),
            env: bindAllFuncs(this, env),
            ...unboundImports
        };
        // We have those imports, and they've been bound to the to-be-instantiated WASM.
        // Now pass those bound imports to WebAssembly.instantiate (or whatever the user specified)
        if (wasmDataOrFetcher instanceof WebAssembly.Module) {
            instance = await WebAssembly.instantiate(wasmDataOrFetcher, imports);
            module = wasmDataOrFetcher;
        }
        else if (wasmDataOrFetcher instanceof ArrayBuffer || ArrayBuffer.isView(wasmDataOrFetcher))
            ({ instance, module } = await WebAssembly.instantiate(wasmDataOrFetcher, imports));
        else if (isResponse(wasmDataOrFetcher))
            ({ instance, module } = await WebAssembly.instantiateStreaming(wasmDataOrFetcher, imports));
        else
            ({ instance, module } = await wasmDataOrFetcher(imports));
        // Do the stuff we couldn't do in the `InstantiatedWasm` constructor because we didn't have these then:
        this.instance = instance;
        this.module = module;
        this.exports = this.instance.exports;
        this.cachedMemoryView = new DataView(this.exports.memory.buffer);
        // Almost done -- now run WASI's `_start` or `_initialize` function.
        console.assert(("_initialize" in this.instance.exports) != ("_start" in this.instance.exports), `Expected either _initialize XOR _start to be exported from this WASM.`);
        (this.exports._initialize ?? this.exports._start)?.();
        // Wait for all Embind calls to resolve (they `await` each other based on the dependencies they need, and this resolves when all dependencies have too)
        await awaitAllEmbind();
    }
    static async instantiate(wasmDataOrFetcher, unboundImports, eventListeners = []) {
        const ret = new InstantiatedWasm();
        for (const args of eventListeners)
            ret.addEventListener(...args);
        await ret.instantiate(wasmDataOrFetcher, unboundImports);
        return ret;
    }
}
// Given an object, binds each function in that object to p (shallowly).
function bindAllFuncs(p, r) {
    return Object.fromEntries(Object.entries(r).map(([key, func]) => { return [key, (typeof func == "function" ? func.bind(p) : func)]; }));
}
// Separated out for type reasons due to "Response" not existing in limited Worklet-like environments.
function isResponse(arg) { return "then" in arg || ("Response" in globalThis && arg instanceof Response); }
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2FzbS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy93YXNtLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUUvRCxPQUFPLEVBQXdDLE1BQU0sWUFBWSxDQUFDO0FBYWxFLHFGQUFxRjtBQUNyRixNQUFNLFlBQVksR0FBRyxXQUE2RixDQUFDO0FBRW5IOztHQUVHO0FBQ0gsTUFBTSxPQUFPLGdCQUFrRixTQUFRLFlBQVk7SUFDL0csc0ZBQXNGO0lBQy9FLE1BQU0sQ0FBcUI7SUFFbEMsc0ZBQXNGO0lBQy9FLFFBQVEsQ0FBdUI7SUFFdEM7Ozs7T0FJRztJQUNJLE1BQU0sQ0FBUztJQUV0Qjs7Ozs7T0FLRztJQUNJLE9BQU8sQ0FBeUI7SUFFdkM7Ozs7O09BS0c7SUFDSSxnQkFBZ0IsQ0FBVztJQUVsQzs7Ozs7O09BTUc7SUFDSDtRQUNJLEtBQUssRUFBRSxDQUFDO1FBQ1IsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixHQUFHLElBQUssQ0FBQTtRQUMxRSxJQUFJLENBQUMsTUFBTSxHQUFHLEVBQVcsQ0FBQztJQUM5QixDQUFDO0lBR0Q7Ozs7Ozs7Ozs7O09BV0c7SUFDSCxLQUFLLENBQUMsV0FBVyxDQUFDLGlCQUEyRyxFQUFFLEVBQUUsc0JBQXNCLEVBQUUsR0FBRyxFQUFFLEdBQUcsY0FBYyxFQUFnQjtRQUMzTCxpRUFBaUU7UUFDakUsSUFBSSxNQUEwQixDQUFDO1FBQy9CLElBQUksUUFBOEIsQ0FBQztRQUduQywrREFBK0Q7UUFDL0QsaUVBQWlFO1FBQ2pFLDBEQUEwRDtRQUUxRCxzREFBc0Q7UUFDdEQsNkdBQTZHO1FBQzdHLGdGQUFnRjtRQUNoRixNQUFNLE9BQU8sR0FBRztZQUNaLHNCQUFzQixFQUFFLFlBQVksQ0FBQyxJQUFJLEVBQUUsc0JBQXNCLENB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VSxDQUFDLEdBQVcsSUFBNkMsT0FBTyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsVUFBVSxJQUFJLFVBQVUsSUFBSSxHQUFHLFlBQVksUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXdhaXRBbGxFbWJpbmQgfSBmcm9tIFwiLi9fcHJpdmF0ZS9lbWJpbmQvcmVnaXN0ZXIuanNcIjtcclxuaW1wb3J0IHR5cGUgeyBFdmVudFR5cGVzTWFwIH0gZnJvbSBcIi4vX3ByaXZhdGUvZXZlbnQtdHlwZXMtbWFwLmpzXCI7XHJcbmltcG9ydCB7IHR5cGUgS25vd25FeHBvcnRzLCB0eXBlIEtub3duSW1wb3J0cyB9IGZyb20gXCIuL3R5cGVzLmpzXCI7XHJcblxyXG5cclxuZXhwb3J0IHR5cGUgUm9sbHVwV2FzbVByb21pc2U8SSBleHRlbmRzIEtub3duSW1wb3J0cyA9IEtub3duSW1wb3J0cz4gPSAoaW1wb3J0cz86IEkpID0+IFByb21pc2U8V2ViQXNzZW1ibHkuV2ViQXNzZW1ibHlJbnN0YW50aWF0ZWRTb3VyY2U+O1xyXG5cclxuXHJcblxyXG5pbnRlcmZhY2UgSW5zdGFudGlhdGVkV2FzbUV2ZW50VGFyZ2V0IGV4dGVuZHMgRXZlbnRUYXJnZXQge1xyXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjxLIGV4dGVuZHMga2V5b2YgRXZlbnRUeXBlc01hcD4odHlwZTogSywgbGlzdGVuZXI6ICh0aGlzOiBGaWxlUmVhZGVyLCBldjogRXZlbnRUeXBlc01hcFtLXSkgPT4gdW5rbm93biwgb3B0aW9ucz86IGJvb2xlYW4gfCBBZGRFdmVudExpc3RlbmVyT3B0aW9ucyk6IHZvaWQ7XHJcbiAgICBhZGRFdmVudExpc3RlbmVyKHR5cGU6IHN0cmluZywgY2FsbGJhY2s6IEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3QgfCBudWxsLCBvcHRpb25zPzogRXZlbnRMaXN0ZW5lck9wdGlvbnMgfCBib29sZWFuKTogdm9pZDtcclxufVxyXG5cclxuXHJcbi8vICBUaGlzIHJlYXNzaWdubWVudCBpcyBhIFR5cGVzY3JpcHQgaGFjayB0byBhZGQgY3VzdG9tIHR5cGVzIHRvIGFkZEV2ZW50TGlzdGVuZXIuLi5cclxuY29uc3QgRXZlbnRUYXJnZXRXID0gRXZlbnRUYXJnZXQgYXMgeyBuZXcoKTogSW5zdGFudGlhdGVkV2FzbUV2ZW50VGFyZ2V0OyBwcm90b3R5cGU6IEluc3RhbnRpYXRlZFdhc21FdmVudFRhcmdldCB9O1xyXG5cclxuLyoqXHJcbiAqIEV4dGVuc2lvbiBvZiBgV2ViQXNzZW1ibHkuV2ViQXNzZW1ibHlJbnN0YW50aWF0ZWRTb3VyY2VgIHRoYXQgaXMgYWxzbyBhbiBgRXZlbnRUYXJnZXRgIGZvciBhbGwgV0FTSSBcImV2ZW50XCJzICh3aGljaCwgeWVzLCBpcyB3aHkgdGhpcyBpcyBhbiBlbnRpcmUgYGNsYXNzYCkuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSW5zdGFudGlhdGVkV2FzbTxFeHBvcnRzIGV4dGVuZHMgb2JqZWN0ID0gb2JqZWN0LCBFbWJpbmQgZXh0ZW5kcyBvYmplY3QgPSBvYmplY3Q+IGV4dGVuZHMgRXZlbnRUYXJnZXRXIGltcGxlbWVudHMgV2ViQXNzZW1ibHkuV2ViQXNzZW1ibHlJbnN0YW50aWF0ZWRTb3VyY2Uge1xyXG4gICAgLyoqIFRoZSBgV2ViQXNzZW1ibHkuTW9kdWxlYCB0aGlzIGluc3RhbmNlIHdhcyBidWlsdCBmcm9tLiBSYXJlbHkgdXNlZnVsIGJ5IGl0c2VsZi4gKi9cclxuICAgIHB1YmxpYyBtb2R1bGU6IFdlYkFzc2VtYmx5Lk1vZHVsZTtcclxuXHJcbiAgICAvKiogVGhlIGBXZWJBc3NlbWJseS5Nb2R1bGVgIHRoaXMgaW5zdGFuY2Ugd2FzIGJ1aWx0IGZyb20uIFJhcmVseSB1c2VmdWwgYnkgaXRzZWxmLiAqL1xyXG4gICAgcHVibGljIGluc3RhbmNlOiBXZWJBc3NlbWJseS5JbnN0YW5jZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnRhaW5zIGV2ZXJ5dGhpbmcgZXhwb3J0ZWQgdXNpbmcgZW1iaW5kLlxyXG4gICAgICogXHJcbiAgICAgKiBUaGVzZSBhcmUgc2VwYXJhdGUgZnJvbSByZWd1bGFyIGV4cG9ydHMgb24gYGluc3RhbmNlLmV4cG9ydGAuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBlbWJpbmQ6IEVtYmluZDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBUaGUgXCJyYXdcIiBXQVNNIGV4cG9ydHMuIE5vbmUgYXJlIHByZWZpeGVkIHdpdGggXCJfXCIuXHJcbiAgICAgKiBcclxuICAgICAqIE5vIGNvbnZlcnNpb24gaXMgcGVyZm9ybWVkIG9uIHRoZSB0eXBlcyBoZXJlOyBldmVyeXRoaW5nIHRha2VzIG9yIHJldHVybnMgYSBudW1iZXIuXHJcbiAgICAgKiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGV4cG9ydHM6IEV4cG9ydHMgJiBLbm93bkV4cG9ydHM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBgZXhwb3J0cy5tZW1vcnlgLCBidXQgdXBkYXRlZCB3aGVuL2lmIG1vcmUgbWVtb3J5IGlzIGFsbG9jYXRlZC5cclxuICAgICAqIFxyXG4gICAgICogR2VuZXJhbGx5IHNwZWFraW5nLCBpdCdzIG1vcmUgY29udmVuaWVudCB0byB1c2UgdGhlIGdlbmVyYWwtcHVycG9zZSBgcmVhZFVpbnQzMmAgZnVuY3Rpb25zLFxyXG4gICAgICogc2luY2UgdGhleSBhY2NvdW50IGZvciBgRGF0YVZpZXdgIGJlaW5nIGJpZy1lbmRpYW4gYnkgZGVmYXVsdC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNhY2hlZE1lbW9yeVZpZXc6IERhdGFWaWV3O1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqICoqSU1QT1JUQU5UKio6IFVudGlsIGBpbml0aWFsaXplYCBpcyBjYWxsZWQsIG5vIFdBU00tcmVsYXRlZCBtZXRob2RzL2ZpZWxkcyBjYW4gYmUgdXNlZC4gXHJcbiAgICAgKiBcclxuICAgICAqIGBhZGRFdmVudExpc3RlbmVyYCBhbmQgb3RoZXIgYEV2ZW50VGFyZ2V0YCBtZXRob2RzIGFyZSBmaW5lLCB0aG91Z2gsIGFuZCBpbiBmYWN0IGFyZSByZXF1aXJlZCBmb3IgZXZlbnRzIHRoYXQgb2NjdXIgZHVyaW5nIGBfaW5pdGlhbGl6ZWAgb3IgYF9zdGFydGAuXHJcbiAgICAgKiBcclxuICAgICAqIElmIHlvdSBkb24ndCBjYXJlIGFib3V0IGV2ZW50cyBkdXJpbmcgaW5pdGlhbGl6YXRpb24sIHlvdSBjYW4gYWxzbyBqdXN0IGNhbGwgYEluc3RhbnRpYXRlZFdhc20uaW5zdGFudGlhdGVgLCB3aGljaCBpcyBhbiBhc3luYyBmdW5jdGlvbiB0aGF0IGRvZXMgYm90aCBpbiBvbmUgc3RlcC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLm1vZHVsZSA9IHRoaXMuaW5zdGFuY2UgPSB0aGlzLmV4cG9ydHMgPSB0aGlzLmNhY2hlZE1lbW9yeVZpZXcgPSBudWxsIVxyXG4gICAgICAgIHRoaXMuZW1iaW5kID0ge30gYXMgbmV2ZXI7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zdGFudGlhdGVzIGEgV0FTTSBtb2R1bGUgd2l0aCB0aGUgc3BlY2lmaWVkIFdBU0kgaW1wb3J0cy5cclxuICAgICAqIFxyXG4gICAgICogYGlucHV0YCBjYW4gYmUgYW55IG9uZSBvZjpcclxuICAgICAqIFxyXG4gICAgICogKiBgUmVzcG9uc2VgIG9yIGBQcm9taXNlPFJlc3BvbnNlPmAgKGZyb20gZS5nLiBgZmV0Y2hgKS4gVXNlcyBgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmdgLlxyXG4gICAgICogKiBgQXJyYXlCdWZmZXJgIHJlcHJlc2VudGluZyB0aGUgV0FTTSBpbiBiaW5hcnkgZm9ybSwgb3IgYSBgV2ViQXNzZW1ibHkuTW9kdWxlYC4gXHJcbiAgICAgKiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyAxIGFyZ3VtZW50IG9mIHR5cGUgYFdlYkFzc2VtYmx5LkltcG9ydHNgIGFuZCByZXR1cm5zIGEgYFdlYkFzc2VtYmx5LldlYkFzc2VtYmx5SW5zdGFudGlhdGVkU291cmNlYC4gVGhpcyBpcyB0aGUgdHlwZSB0aGF0IGBAcm9sbHVwL3BsdWdpbi13YXNtYCByZXR1cm5zIHdoZW4gYnVuZGxpbmcgYSBwcmUtYnVpbHQgV0FTTSBiaW5hcnkuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB3YXNtRmV0Y2hQcm9taXNlIFxyXG4gICAgICogQHBhcmFtIHVuYm91bmRJbXBvcnRzIFxyXG4gICAgICovXHJcbiAgICBhc3luYyBpbnN0YW50aWF0ZSh3YXNtRGF0YU9yRmV0Y2hlcjogUm9sbHVwV2FzbVByb21pc2UgfCBXZWJBc3NlbWJseS5Nb2R1bGUgfCBCdWZmZXJTb3VyY2UgfCBSZXNwb25zZSB8IFByb21pc2VMaWtlPFJlc3BvbnNlPiwgeyB3YXNpX3NuYXBzaG90X3ByZXZpZXcxLCBlbnYsIC4uLnVuYm91bmRJbXBvcnRzIH06IEtub3duSW1wb3J0cyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIC8vIChUaGVzZSBhcmUganVzdCB1cCBoZXJlIHRvIG5vdCBnZXQgaW4gdGhlIHdheSBvZiB0aGUgY29tbWVudHMpXHJcbiAgICAgICAgbGV0IG1vZHVsZTogV2ViQXNzZW1ibHkuTW9kdWxlO1xyXG4gICAgICAgIGxldCBpbnN0YW5jZTogV2ViQXNzZW1ibHkuSW5zdGFuY2U7XHJcblxyXG5cclxuICAgICAgICAvLyBUaGVyZSdzIGEgYml0IG9mIHNvbmcgYW5kIGRhbmNlIHRvIGdldCBhcm91bmQgdGhlIGZhY3QgdGhhdDpcclxuICAgICAgICAvLyAxLiBXQVNNIG5lZWRzIGl0cyBXQVNJIGltcG9ydHMgaW1tZWRpYXRlbHkgdXBvbiBpbnN0YW50aWF0aW9uLlxyXG4gICAgICAgIC8vIDIuIFdBU0kgbmVlZHMgaXRzIFdBU00gYEluc3RhbmNlYCBpbiBvcmRlciB0byBmdW5jdGlvbi5cclxuXHJcbiAgICAgICAgLy8gRmlyc3QsIGJpbmQgYWxsIG9mIG91ciBpbXBvcnRzIHRvIHRoZSBzYW1lIG9iamVjdCwgXHJcbiAgICAgICAgLy8gd2hpY2ggYWxzbyBoYXBwZW5zIHRvIGJlIHRoZSBJbnN0YW50aWF0ZWRXYXNtIHdlJ3JlIHJldHVybmluZyAoYnV0IGNvdWxkIHRoZW9yZXRpY2FsbHkgYmUgc29tZXRoaW5nIGVsc2UpLlxyXG4gICAgICAgIC8vIFRoaXMgaXMgaG93IHRoZXknbGwgYmUgYWJsZSB0byBhY2Nlc3MgbWVtb3J5IGFuZCBjb21tdW5pY2F0ZSB3aXRoIGVhY2ggb3RoZXIuXHJcbiAgICAgICAgY29uc3QgaW1wb3J0cyA9IHtcclxuICAgICAgICAgICAgd2FzaV9zbmFwc2hvdF9wcmV2aWV3MTogYmluZEFsbEZ1bmNzKHRoaXMsIHdhc2lfc25hcHNob3RfcHJldmlldzEpLFxyXG4gICAgICAgICAgICBlbnY6IGJpbmRBbGxGdW5jcyh0aGlzLCBlbnYpLFxyXG4gICAgICAgICAgICAuLi51bmJvdW5kSW1wb3J0c1xyXG4gICAgICAgIH0gYXMgS25vd25JbXBvcnRzICYgV2ViQXNzZW1ibHkuSW1wb3J0cztcclxuXHJcbiAgICAgICAgLy8gV2UgaGF2ZSB0aG9zZSBpbXBvcnRzLCBhbmQgdGhleSd2ZSBiZWVuIGJvdW5kIHRvIHRoZSB0by1iZS1pbnN0YW50aWF0ZWQgV0FTTS5cclxuICAgICAgICAvLyBOb3cgcGFzcyB0aG9zZSBib3VuZCBpbXBvcnRzIHRvIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlIChvciB3aGF0ZXZlciB0aGUgdXNlciBzcGVjaWZpZWQpXHJcbiAgICAgICAgaWYgKHdhc21EYXRhT3JGZXRjaGVyIGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuTW9kdWxlKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlID0gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUod2FzbURhdGFPckZldGNoZXIsIGltcG9ydHMpXHJcbiAgICAgICAgICAgIG1vZHVsZSA9IHdhc21EYXRhT3JGZXRjaGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh3YXNtRGF0YU9yRmV0Y2hlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyh3YXNtRGF0YU9yRmV0Y2hlcikpXHJcbiAgICAgICAgICAgICh7IGluc3RhbmNlLCBtb2R1bGUgfSA9IGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHdhc21EYXRhT3JGZXRjaGVyLCBpbXBvcnRzKSk7XHJcbiAgICAgICAgZWxzZSBpZiAoaXNSZXNwb25zZSh3YXNtRGF0YU9yRmV0Y2hlcikpXHJcbiAgICAgICAgICAgICh7IGluc3RhbmNlLCBtb2R1bGUgfSA9IGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHdhc21EYXRhT3JGZXRjaGVyLCBpbXBvcnRzKSk7XHJcblxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgKHsgaW5zdGFuY2UsIG1vZHVsZSB9ID0gYXdhaXQgd2FzbURhdGFPckZldGNoZXIoaW1wb3J0cykpO1xyXG5cclxuXHJcbiAgICAgICAgLy8gRG8gdGhlIHN0dWZmIHdlIGNvdWxkbid0IGRvIGluIHRoZSBgSW5zdGFudGlhdGVkV2FzbWAgY29uc3RydWN0b3IgYmVjYXVzZSB3ZSBkaWRuJ3QgaGF2ZSB0aGVzZSB0aGVuOlxyXG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcclxuICAgICAgICB0aGlzLm1vZHVsZSA9IG1vZHVsZTtcclxuICAgICAgICB0aGlzLmV4cG9ydHMgPSB0aGlzLmluc3RhbmNlLmV4cG9ydHMgYXMgRXhwb3J0cyBhcyBFeHBvcnRzICYgS25vd25FeHBvcnRzO1xyXG4gICAgICAgIHRoaXMuY2FjaGVkTWVtb3J5VmlldyA9IG5ldyBEYXRhVmlldyh0aGlzLmV4cG9ydHMubWVtb3J5LmJ1ZmZlcik7XHJcblxyXG4gICAgICAgIC8vIEFsbW9zdCBkb25lIC0tIG5vdyBydW4gV0FTSSdzIGBfc3RhcnRgIG9yIGBfaW5pdGlhbGl6ZWAgZnVuY3Rpb24uXHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQoKFwiX2luaXRpYWxpemVcIiBpbiB0aGlzLmluc3RhbmNlLmV4cG9ydHMpICE9IChcIl9zdGFydFwiIGluIHRoaXMuaW5zdGFuY2UuZXhwb3J0cyksIGBFeHBlY3RlZCBlaXRoZXIgX2luaXRpYWxpemUgWE9SIF9zdGFydCB0byBiZSBleHBvcnRlZCBmcm9tIHRoaXMgV0FTTS5gKTtcclxuICAgICAgICAodGhpcy5leHBvcnRzLl9pbml0aWFsaXplID8/IHRoaXMuZXhwb3J0cy5fc3RhcnQpPy4oKTtcclxuXHJcbiAgICAgICAgLy8gV2FpdCBmb3IgYWxsIEVtYmluZCBjYWxscyB0byByZXNvbHZlICh0aGV5IGBhd2FpdGAgZWFjaCBvdGhlciBiYXNlZCBvbiB0aGUgZGVwZW5kZW5jaWVzIHRoZXkgbmVlZCwgYW5kIHRoaXMgcmVzb2x2ZXMgd2hlbiBhbGwgZGVwZW5kZW5jaWVzIGhhdmUgdG9vKVxyXG4gICAgICAgIGF3YWl0IGF3YWl0QWxsRW1iaW5kKCk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGFzeW5jIGluc3RhbnRpYXRlPEV4cG9ydHMgZXh0ZW5kcyBvYmplY3QgPSBvYmplY3QsIEVtYmluZCBleHRlbmRzIG9iamVjdCA9IG9iamVjdD4od2FzbURhdGFPckZldGNoZXI6IFJvbGx1cFdhc21Qcm9taXNlIHwgV2ViQXNzZW1ibHkuTW9kdWxlIHwgQnVmZmVyU291cmNlIHwgUmVzcG9uc2UgfCBQcm9taXNlTGlrZTxSZXNwb25zZT4sIHVuYm91bmRJbXBvcnRzOiBLbm93bkltcG9ydHMsIGV2ZW50TGlzdGVuZXJzOiBQYXJhbWV0ZXJzPEluc3RhbnRpYXRlZFdhc208RXhwb3J0cywgRW1iaW5kPltcImFkZEV2ZW50TGlzdGVuZXJcIl0+W10gPSBbXSk6IFByb21pc2U8SW5zdGFudGlhdGVkV2FzbTxFeHBvcnRzLCBFbWJpbmQ+PiB7XHJcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IEluc3RhbnRpYXRlZFdhc208RXhwb3J0cywgRW1iaW5kPigpO1xyXG4gICAgICAgIGZvciAoY29uc3QgYXJncyBvZiBldmVudExpc3RlbmVycylcclxuICAgICAgICAgICAgcmV0LmFkZEV2ZW50TGlzdGVuZXIoLi4uYXJncyk7XHJcbiAgICAgICAgYXdhaXQgcmV0Lmluc3RhbnRpYXRlKHdhc21EYXRhT3JGZXRjaGVyLCB1bmJvdW5kSW1wb3J0cyk7XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxufVxyXG5cclxuLy8gR2l2ZW4gYW4gb2JqZWN0LCBiaW5kcyBlYWNoIGZ1bmN0aW9uIGluIHRoYXQgb2JqZWN0IHRvIHAgKHNoYWxsb3dseSkuXHJcbmZ1bmN0aW9uIGJpbmRBbGxGdW5jczxSIGV4dGVuZHMgb2JqZWN0PihwOiBJbnN0YW50aWF0ZWRXYXNtLCByOiBSKTogUiB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHIpLm1hcCgoW2tleSwgZnVuY10pID0+IHsgcmV0dXJuIFtrZXksICh0eXBlb2YgZnVuYyA9PSBcImZ1bmN0aW9uXCIgPyAoZnVuYyBhcyAoLi4uYXJnczogdW5rbm93bltdKSA9PiB1bmtub3duKS5iaW5kKHApIDogZnVuYyldIGFzIGNvbnN0OyB9KSkgYXMgUjtcclxufVxyXG5cclxuLy8gU2VwYXJhdGVkIG91dCBmb3IgdHlwZSByZWFzb25zIGR1ZSB0byBcIlJlc3BvbnNlXCIgbm90IGV4aXN0aW5nIGluIGxpbWl0ZWQgV29ya2xldC1saWtlIGVudmlyb25tZW50cy5cclxuZnVuY3Rpb24gaXNSZXNwb25zZShhcmc6IG9iamVjdCk6IGFyZyBpcyBSZXNwb25zZSB8IFByb21pc2VMaWtlPFJlc3BvbnNlPiB7IHJldHVybiBcInRoZW5cIiBpbiBhcmcgfHwgKFwiUmVzcG9uc2VcIiBpbiBnbG9iYWxUaGlzICYmIGFyZyBpbnN0YW5jZW9mIFJlc3BvbnNlKTsgfVxyXG5cclxuIl19