import { awaitAllEmbind } from "./_private/embind/register.js";
import {} from "./types.js";
//  This reassignment is a Typescript hack to add custom types to addEventListener...
const EventTargetW = EventTarget;
/**
 * Extension of `WebAssembly.WebAssemblyInstantiatedSource` that is also an `EventTarget` for all WASI "event"s (which, yes, is why this is an entire `class`).
 */
export class InstantiatedWasm extends EventTargetW {
    /** The `WebAssembly.Module` this instance was built from. Rarely useful by itself. */
    module;
    /** The `WebAssembly.Module` this instance was built from. Rarely useful by itself. */
    instance;
    /**
     * Contains everything exported using embind.
     *
     * These are separate from regular exports on `instance.export`.
     */
    embind;
    /**
     * The "raw" WASM exports. None are prefixed with "_".
     *
     * No conversion is performed on the types here; everything takes or returns a number.
     *
     */
    exports;
    /**
     * `exports.memory`, but updated when/if more memory is allocated.
     *
     * Generally speaking, it's more convenient to use the general-purpose `readUint32` functions,
     * since they account for `DataView` being big-endian by default.
     */
    cachedMemoryView;
    /**
     * Not intended to be called directly. Use the static `instantiate` function instead, which returns one of these.
     *
     * I want to instead just return a promise here sooooooo badly...
     */
    constructor() {
        super();
        this.module = this.instance = this.exports = this.cachedMemoryView = null;
        this.embind = {};
    }
    /**
     * Instantiates a WASM module with the specified WASI imports.
     *
     * `input` can be any one of:
     *
     * * `Response` or `Promise<Response>` (from e.g. `fetch`). Uses `WebAssembly.instantiateStreaming`.
     * * `ArrayBuffer` representing the WASM in binary form, or a `WebAssembly.Module`.
     * * A function that takes 1 argument of type `WebAssembly.Imports` and returns a `WebAssembly.WebAssemblyInstantiatedSource`. This is the type that `@rollup/plugin-wasm` returns when bundling a pre-built WASM binary.
     *
     * @param wasmFetchPromise
     * @param unboundImports
     */
    static async instantiate(wasmDataOrFetcher, { wasi_snapshot_preview1, env, ...unboundImports }) {
        // (These are just up here to not get in the way of the comments)
        let module;
        let instance;
        // There's a bit of song and dance to get around the fact that:
        // 1. WASM needs its WASI imports immediately upon instantiation.
        // 2. WASI needs its WASM `Instance` in order to function.
        // First, bind all of our imports to the same object, 
        // which also happens to be the InstantiatedWasm we're returning (but could theoretically be something else).
        // This is how they'll be able to access memory and communicate with each other.
        const wasm = new InstantiatedWasm();
        const imports = {
            wasi_snapshot_preview1: bindAllFuncs(wasm, wasi_snapshot_preview1),
            env: bindAllFuncs(wasm, env),
            ...unboundImports
        };
        // We have those imports, and they've been bound to the to-be-instantiated WASM.
        // Now pass those bound imports to WebAssembly.instantiate (or whatever the user specified)
        if (wasmDataOrFetcher instanceof WebAssembly.Module) {
            instance = await WebAssembly.instantiate(wasmDataOrFetcher, imports);
            module = wasmDataOrFetcher;
        }
        else if (wasmDataOrFetcher instanceof ArrayBuffer || ArrayBuffer.isView(wasmDataOrFetcher))
            ({ instance, module } = await WebAssembly.instantiate(wasmDataOrFetcher, imports));
        else if (isResponse(wasmDataOrFetcher))
            ({ instance, module } = await WebAssembly.instantiateStreaming(wasmDataOrFetcher, imports));
        else
            ({ instance, module } = await wasmDataOrFetcher(imports));
        // Do the stuff we couldn't do in the `InstantiatedWasm` constructor because we didn't have these then:
        wasm.instance = instance;
        wasm.module = module;
        wasm.exports = wasm.instance.exports;
        wasm.cachedMemoryView = new DataView(wasm.exports.memory.buffer);
        // Almost done -- now run WASI's `_start` or `_initialize` function.
        console.assert(("_initialize" in wasm.instance.exports) != ("_start" in wasm.instance.exports), `Expected either _initialize XOR _start to be exported from this WASM.`);
        (wasm.exports._initialize ?? wasm.exports._start)?.();
        // Wait for all Embind calls to resolve (they `await` each other based on the dependencies they need, and this resolves when all dependencies have too)
        await awaitAllEmbind();
        // And we're finally finished.
        return wasm;
    }
}
// Given an object, binds each function in that object to p (shallowly).
function bindAllFuncs(p, r) {
    return Object.fromEntries(Object.entries(r).map(([key, func]) => { return [key, (typeof func == "function" ? func.bind(p) : func)]; }));
}
// Separated out for type reasons due to "Response" not existing in limited Worklet-like environments.
function isResponse(arg) { return "then" in arg || ("Response" in globalThis && arg instanceof Response); }
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2FzbS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy93YXNtLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUUvRCxPQUFPLEVBQXdDLE1BQU0sWUFBWSxDQUFDO0FBYWxFLHFGQUFxRjtBQUNyRixNQUFNLFlBQVksR0FBRyxXQUE2RixDQUFDO0FBRW5IOztHQUVHO0FBQ0gsTUFBTSxPQUFPLGdCQUFrRixTQUFRLFlBQVk7SUFDL0csc0ZBQXNGO0lBQy9FLE1BQU0sQ0FBcUI7SUFFbEMsc0ZBQXNGO0lBQy9FLFFBQVEsQ0FBdUI7SUFFdEM7Ozs7T0FJRztJQUNJLE1BQU0sQ0FBUztJQUV0Qjs7Ozs7T0FLRztJQUNJLE9BQU8sQ0FBeUI7SUFFdkM7Ozs7O09BS0c7SUFDSSxnQkFBZ0IsQ0FBVztJQUVsQzs7OztPQUlHO0lBQ0g7UUFDSSxLQUFLLEVBQUUsQ0FBQztRQUNSLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFLLENBQUE7UUFDMUUsSUFBSSxDQUFDLE1BQU0sR0FBRyxFQUFXLENBQUM7SUFDOUIsQ0FBQztJQUdEOzs7Ozs7Ozs7OztPQVdHO0lBQ0gsTUFBTSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQWdELGlCQUEyRyxFQUFFLEVBQUUsc0JBQXNCLEVBQUUsR0FBRyxFQUFFLEdBQUcsY0FBYyxFQUFnQjtRQUNqUCxpRUFBaUU7UUFDakUsSUFBSSxNQUEwQixDQUFDO1FBQy9CLElBQUksUUFBOEIsQ0FBQztRQUduQywrREFBK0Q7UUFDL0QsaUVBQWlFO1FBQ2pFLDBEQUEwRDtRQUUxRCxzREFBc0Q7UUFDdEQsNkdBQTZHO1FBQzdHLGdGQUFnRjtRQUNoRixNQUFNLElBQUksR0FBc0MsSUFBSSxnQkFBZ0IsRUFBbUIsQ0FBQztRQUN4RixNQUFNLE9BQU8sR0FBRztZQUNaLHNCQUFzQixFQUFFLFlBQVksQ0FBQyxJQUFJLEVBQUUsc0JBQXNCLENBQUM7WUFDbEUsR0FBRyxFQUFFLFlBQVksQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDO1lBQzVCLEdBQUcsY0FBYztTQUNrQixDQUFDO1FBRXhDLGdGQUFnRjtRQUNoRiwyRkFBMkY7UUFDM0YsSUFBSSxpQkFBaUIsWUFBWSxXQUFXLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDbEQsUUFBUSxHQUFHLE1BQU0sV0FBVyxDQUFDLFdBQVcsQ0FBQyxpQkFBaUIsRUFBRSxPQUFPLENBQUMsQ0FBQTtZQUNwRSxNQUFNLEdBQUcsaUJBQWlCLENBQUM7UUFDL0IsQ0FBQzthQUNJLElBQUksaUJBQWlCLFlBQVksV0FBVyxJQUFJLFdBQVcsQ0FBQyxNQUFNLENBQUMsaUJBQWlCLENBQUM7WUFDdEYsQ0FBQyxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsR0FBRyxNQUFNLFdBQVcsQ0FBQyxXQUFXLENBQUMsaUJBQWlCLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQzthQUNsRixJQUFJLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQztZQUNsQyxDQUFDLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxHQUFHLE1BQU0sV0FBVyxDQUFDLG9CQUFvQixDQUFDLGlCQUFpQixFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUM7O1lBRzVGLENBQUMsRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLEdBQUcsTUFBTSxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1FBRzlELHVHQUF1RztRQUN2RyxJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUNyQixJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBNEMsQ0FBQztRQUMxRSxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFakUsb0VBQW9FO1FBQ3BFLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxhQUFhLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFLHVFQUF1RSxDQUFDLENBQUM7UUFDekssQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsQ0FBQztRQUV0RCx1SkFBdUo7UUFDdkosTUFBTSxjQUFjLEVBQUUsQ0FBQztRQUV2Qiw4QkFBOEI7UUFDOUIsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztDQUNKO0FBRUQsd0VBQXdFO0FBQ3hFLFNBQVMsWUFBWSxDQUFtQixDQUFtQixFQUFFLENBQUk7SUFDN0QsT0FBTyxNQUFNLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFHLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxPQUFPLElBQUksSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFFLElBQXdDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQU0sQ0FBQztBQUMvTCxDQUFDO0FBRUQsc0dBQXNHO0FBQ3RHLFNBQVMsVUFBVSxDQUFDLEdBQVcsSUFBNkMsT0FBTyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsVUFBVSxJQUFJLFVBQVUsSUFBSSxHQUFHLFlBQVksUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXdhaXRBbGxFbWJpbmQgfSBmcm9tIFwiLi9fcHJpdmF0ZS9lbWJpbmQvcmVnaXN0ZXIuanNcIjtcclxuaW1wb3J0IHR5cGUgeyBFdmVudFR5cGVzTWFwIH0gZnJvbSBcIi4vX3ByaXZhdGUvZXZlbnQtdHlwZXMtbWFwLmpzXCI7XHJcbmltcG9ydCB7IHR5cGUgS25vd25FeHBvcnRzLCB0eXBlIEtub3duSW1wb3J0cyB9IGZyb20gXCIuL3R5cGVzLmpzXCI7XHJcblxyXG5cclxuZXhwb3J0IHR5cGUgUm9sbHVwV2FzbVByb21pc2U8SSBleHRlbmRzIEtub3duSW1wb3J0cyA9IEtub3duSW1wb3J0cz4gPSAoaW1wb3J0cz86IEkpID0+IFByb21pc2U8V2ViQXNzZW1ibHkuV2ViQXNzZW1ibHlJbnN0YW50aWF0ZWRTb3VyY2U+O1xyXG5cclxuXHJcblxyXG5pbnRlcmZhY2UgSW5zdGFudGlhdGVkV2FzbUV2ZW50VGFyZ2V0IGV4dGVuZHMgRXZlbnRUYXJnZXQge1xyXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjxLIGV4dGVuZHMga2V5b2YgRXZlbnRUeXBlc01hcD4odHlwZTogSywgbGlzdGVuZXI6ICh0aGlzOiBGaWxlUmVhZGVyLCBldjogRXZlbnRUeXBlc01hcFtLXSkgPT4gdW5rbm93biwgb3B0aW9ucz86IGJvb2xlYW4gfCBBZGRFdmVudExpc3RlbmVyT3B0aW9ucyk6IHZvaWQ7XHJcbiAgICBhZGRFdmVudExpc3RlbmVyKHR5cGU6IHN0cmluZywgY2FsbGJhY2s6IEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3QgfCBudWxsLCBvcHRpb25zPzogRXZlbnRMaXN0ZW5lck9wdGlvbnMgfCBib29sZWFuKTogdm9pZDtcclxufVxyXG5cclxuXHJcbi8vICBUaGlzIHJlYXNzaWdubWVudCBpcyBhIFR5cGVzY3JpcHQgaGFjayB0byBhZGQgY3VzdG9tIHR5cGVzIHRvIGFkZEV2ZW50TGlzdGVuZXIuLi5cclxuY29uc3QgRXZlbnRUYXJnZXRXID0gRXZlbnRUYXJnZXQgYXMgeyBuZXcoKTogSW5zdGFudGlhdGVkV2FzbUV2ZW50VGFyZ2V0OyBwcm90b3R5cGU6IEluc3RhbnRpYXRlZFdhc21FdmVudFRhcmdldCB9O1xyXG5cclxuLyoqXHJcbiAqIEV4dGVuc2lvbiBvZiBgV2ViQXNzZW1ibHkuV2ViQXNzZW1ibHlJbnN0YW50aWF0ZWRTb3VyY2VgIHRoYXQgaXMgYWxzbyBhbiBgRXZlbnRUYXJnZXRgIGZvciBhbGwgV0FTSSBcImV2ZW50XCJzICh3aGljaCwgeWVzLCBpcyB3aHkgdGhpcyBpcyBhbiBlbnRpcmUgYGNsYXNzYCkuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSW5zdGFudGlhdGVkV2FzbTxFeHBvcnRzIGV4dGVuZHMgb2JqZWN0ID0gb2JqZWN0LCBFbWJpbmQgZXh0ZW5kcyBvYmplY3QgPSBvYmplY3Q+IGV4dGVuZHMgRXZlbnRUYXJnZXRXIGltcGxlbWVudHMgV2ViQXNzZW1ibHkuV2ViQXNzZW1ibHlJbnN0YW50aWF0ZWRTb3VyY2Uge1xyXG4gICAgLyoqIFRoZSBgV2ViQXNzZW1ibHkuTW9kdWxlYCB0aGlzIGluc3RhbmNlIHdhcyBidWlsdCBmcm9tLiBSYXJlbHkgdXNlZnVsIGJ5IGl0c2VsZi4gKi9cclxuICAgIHB1YmxpYyBtb2R1bGU6IFdlYkFzc2VtYmx5Lk1vZHVsZTtcclxuXHJcbiAgICAvKiogVGhlIGBXZWJBc3NlbWJseS5Nb2R1bGVgIHRoaXMgaW5zdGFuY2Ugd2FzIGJ1aWx0IGZyb20uIFJhcmVseSB1c2VmdWwgYnkgaXRzZWxmLiAqL1xyXG4gICAgcHVibGljIGluc3RhbmNlOiBXZWJBc3NlbWJseS5JbnN0YW5jZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnRhaW5zIGV2ZXJ5dGhpbmcgZXhwb3J0ZWQgdXNpbmcgZW1iaW5kLlxyXG4gICAgICogXHJcbiAgICAgKiBUaGVzZSBhcmUgc2VwYXJhdGUgZnJvbSByZWd1bGFyIGV4cG9ydHMgb24gYGluc3RhbmNlLmV4cG9ydGAuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBlbWJpbmQ6IEVtYmluZDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBUaGUgXCJyYXdcIiBXQVNNIGV4cG9ydHMuIE5vbmUgYXJlIHByZWZpeGVkIHdpdGggXCJfXCIuXHJcbiAgICAgKiBcclxuICAgICAqIE5vIGNvbnZlcnNpb24gaXMgcGVyZm9ybWVkIG9uIHRoZSB0eXBlcyBoZXJlOyBldmVyeXRoaW5nIHRha2VzIG9yIHJldHVybnMgYSBudW1iZXIuXHJcbiAgICAgKiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGV4cG9ydHM6IEV4cG9ydHMgJiBLbm93bkV4cG9ydHM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBgZXhwb3J0cy5tZW1vcnlgLCBidXQgdXBkYXRlZCB3aGVuL2lmIG1vcmUgbWVtb3J5IGlzIGFsbG9jYXRlZC5cclxuICAgICAqIFxyXG4gICAgICogR2VuZXJhbGx5IHNwZWFraW5nLCBpdCdzIG1vcmUgY29udmVuaWVudCB0byB1c2UgdGhlIGdlbmVyYWwtcHVycG9zZSBgcmVhZFVpbnQzMmAgZnVuY3Rpb25zLFxyXG4gICAgICogc2luY2UgdGhleSBhY2NvdW50IGZvciBgRGF0YVZpZXdgIGJlaW5nIGJpZy1lbmRpYW4gYnkgZGVmYXVsdC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNhY2hlZE1lbW9yeVZpZXc6IERhdGFWaWV3O1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIE5vdCBpbnRlbmRlZCB0byBiZSBjYWxsZWQgZGlyZWN0bHkuIFVzZSB0aGUgc3RhdGljIGBpbnN0YW50aWF0ZWAgZnVuY3Rpb24gaW5zdGVhZCwgd2hpY2ggcmV0dXJucyBvbmUgb2YgdGhlc2UuXHJcbiAgICAgKiBcclxuICAgICAqIEkgd2FudCB0byBpbnN0ZWFkIGp1c3QgcmV0dXJuIGEgcHJvbWlzZSBoZXJlIHNvb29vb29vIGJhZGx5Li4uXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLm1vZHVsZSA9IHRoaXMuaW5zdGFuY2UgPSB0aGlzLmV4cG9ydHMgPSB0aGlzLmNhY2hlZE1lbW9yeVZpZXcgPSBudWxsIVxyXG4gICAgICAgIHRoaXMuZW1iaW5kID0ge30gYXMgbmV2ZXI7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zdGFudGlhdGVzIGEgV0FTTSBtb2R1bGUgd2l0aCB0aGUgc3BlY2lmaWVkIFdBU0kgaW1wb3J0cy5cclxuICAgICAqIFxyXG4gICAgICogYGlucHV0YCBjYW4gYmUgYW55IG9uZSBvZjpcclxuICAgICAqIFxyXG4gICAgICogKiBgUmVzcG9uc2VgIG9yIGBQcm9taXNlPFJlc3BvbnNlPmAgKGZyb20gZS5nLiBgZmV0Y2hgKS4gVXNlcyBgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmdgLlxyXG4gICAgICogKiBgQXJyYXlCdWZmZXJgIHJlcHJlc2VudGluZyB0aGUgV0FTTSBpbiBiaW5hcnkgZm9ybSwgb3IgYSBgV2ViQXNzZW1ibHkuTW9kdWxlYC4gXHJcbiAgICAgKiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyAxIGFyZ3VtZW50IG9mIHR5cGUgYFdlYkFzc2VtYmx5LkltcG9ydHNgIGFuZCByZXR1cm5zIGEgYFdlYkFzc2VtYmx5LldlYkFzc2VtYmx5SW5zdGFudGlhdGVkU291cmNlYC4gVGhpcyBpcyB0aGUgdHlwZSB0aGF0IGBAcm9sbHVwL3BsdWdpbi13YXNtYCByZXR1cm5zIHdoZW4gYnVuZGxpbmcgYSBwcmUtYnVpbHQgV0FTTSBiaW5hcnkuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB3YXNtRmV0Y2hQcm9taXNlIFxyXG4gICAgICogQHBhcmFtIHVuYm91bmRJbXBvcnRzIFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYXN5bmMgaW5zdGFudGlhdGU8RXhwb3J0cyBleHRlbmRzIG9iamVjdCwgRW1iaW5kIGV4dGVuZHMgb2JqZWN0Pih3YXNtRGF0YU9yRmV0Y2hlcjogUm9sbHVwV2FzbVByb21pc2UgfCBXZWJBc3NlbWJseS5Nb2R1bGUgfCBCdWZmZXJTb3VyY2UgfCBSZXNwb25zZSB8IFByb21pc2VMaWtlPFJlc3BvbnNlPiwgeyB3YXNpX3NuYXBzaG90X3ByZXZpZXcxLCBlbnYsIC4uLnVuYm91bmRJbXBvcnRzIH06IEtub3duSW1wb3J0cyk6IFByb21pc2U8SW5zdGFudGlhdGVkV2FzbTxFeHBvcnRzLCBFbWJpbmQ+PiB7XHJcbiAgICAgICAgLy8gKFRoZXNlIGFyZSBqdXN0IHVwIGhlcmUgdG8gbm90IGdldCBpbiB0aGUgd2F5IG9mIHRoZSBjb21tZW50cylcclxuICAgICAgICBsZXQgbW9kdWxlOiBXZWJBc3NlbWJseS5Nb2R1bGU7XHJcbiAgICAgICAgbGV0IGluc3RhbmNlOiBXZWJBc3NlbWJseS5JbnN0YW5jZTtcclxuXHJcblxyXG4gICAgICAgIC8vIFRoZXJlJ3MgYSBiaXQgb2Ygc29uZyBhbmQgZGFuY2UgdG8gZ2V0IGFyb3VuZCB0aGUgZmFjdCB0aGF0OlxyXG4gICAgICAgIC8vIDEuIFdBU00gbmVlZHMgaXRzIFdBU0kgaW1wb3J0cyBpbW1lZGlhdGVseSB1cG9uIGluc3RhbnRpYXRpb24uXHJcbiAgICAgICAgLy8gMi4gV0FTSSBuZWVkcyBpdHMgV0FTTSBgSW5zdGFuY2VgIGluIG9yZGVyIHRvIGZ1bmN0aW9uLlxyXG5cclxuICAgICAgICAvLyBGaXJzdCwgYmluZCBhbGwgb2Ygb3VyIGltcG9ydHMgdG8gdGhlIHNhbWUgb2JqZWN0LCBcclxuICAgICAgICAvLyB3aGljaCBhbHNvIGhhcHBlbnMgdG8gYmUgdGhlIEluc3RhbnRpYXRlZFdhc20gd2UncmUgcmV0dXJuaW5nIChidXQgY291bGQgdGhlb3JldGljYWxseSBiZSBzb21ldGhpbmcgZWxzZSkuXHJcbiAgICAgICAgLy8gVGhpcyBpcyBob3cgdGhleSdsbCBiZSBhYmxlIHRvIGFjY2VzcyBtZW1vcnkgYW5kIGNvbW11bmljYXRlIHdpdGggZWFjaCBvdGhlci5cclxuICAgICAgICBjb25zdCB3YXNtOiBJbnN0YW50aWF0ZWRXYXNtPEV4cG9ydHMsIEVtYmluZD4gPSBuZXcgSW5zdGFudGlhdGVkV2FzbTxFeHBvcnRzLCBFbWJpbmQ+KCk7XHJcbiAgICAgICAgY29uc3QgaW1wb3J0cyA9IHtcclxuICAgICAgICAgICAgd2FzaV9zbmFwc2hvdF9wcmV2aWV3MTogYmluZEFsbEZ1bmNzKHdhc20sIHdhc2lfc25hcHNob3RfcHJldmlldzEpLFxyXG4gICAgICAgICAgICBlbnY6IGJpbmRBbGxGdW5jcyh3YXNtLCBlbnYpLFxyXG4gICAgICAgICAgICAuLi51bmJvdW5kSW1wb3J0c1xyXG4gICAgICAgIH0gYXMgS25vd25JbXBvcnRzICYgV2ViQXNzZW1ibHkuSW1wb3J0cztcclxuXHJcbiAgICAgICAgLy8gV2UgaGF2ZSB0aG9zZSBpbXBvcnRzLCBhbmQgdGhleSd2ZSBiZWVuIGJvdW5kIHRvIHRoZSB0by1iZS1pbnN0YW50aWF0ZWQgV0FTTS5cclxuICAgICAgICAvLyBOb3cgcGFzcyB0aG9zZSBib3VuZCBpbXBvcnRzIHRvIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlIChvciB3aGF0ZXZlciB0aGUgdXNlciBzcGVjaWZpZWQpXHJcbiAgICAgICAgaWYgKHdhc21EYXRhT3JGZXRjaGVyIGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuTW9kdWxlKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlID0gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUod2FzbURhdGFPckZldGNoZXIsIGltcG9ydHMpXHJcbiAgICAgICAgICAgIG1vZHVsZSA9IHdhc21EYXRhT3JGZXRjaGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh3YXNtRGF0YU9yRmV0Y2hlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyh3YXNtRGF0YU9yRmV0Y2hlcikpXHJcbiAgICAgICAgICAgICh7IGluc3RhbmNlLCBtb2R1bGUgfSA9IGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHdhc21EYXRhT3JGZXRjaGVyLCBpbXBvcnRzKSk7XHJcbiAgICAgICAgZWxzZSBpZiAoaXNSZXNwb25zZSh3YXNtRGF0YU9yRmV0Y2hlcikpXHJcbiAgICAgICAgICAgICh7IGluc3RhbmNlLCBtb2R1bGUgfSA9IGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHdhc21EYXRhT3JGZXRjaGVyLCBpbXBvcnRzKSk7XHJcblxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgKHsgaW5zdGFuY2UsIG1vZHVsZSB9ID0gYXdhaXQgd2FzbURhdGFPckZldGNoZXIoaW1wb3J0cykpO1xyXG5cclxuXHJcbiAgICAgICAgLy8gRG8gdGhlIHN0dWZmIHdlIGNvdWxkbid0IGRvIGluIHRoZSBgSW5zdGFudGlhdGVkV2FzbWAgY29uc3RydWN0b3IgYmVjYXVzZSB3ZSBkaWRuJ3QgaGF2ZSB0aGVzZSB0aGVuOlxyXG4gICAgICAgIHdhc20uaW5zdGFuY2UgPSBpbnN0YW5jZTtcclxuICAgICAgICB3YXNtLm1vZHVsZSA9IG1vZHVsZTtcclxuICAgICAgICB3YXNtLmV4cG9ydHMgPSB3YXNtLmluc3RhbmNlLmV4cG9ydHMgYXMgRXhwb3J0cyBhcyBFeHBvcnRzICYgS25vd25FeHBvcnRzO1xyXG4gICAgICAgIHdhc20uY2FjaGVkTWVtb3J5VmlldyA9IG5ldyBEYXRhVmlldyh3YXNtLmV4cG9ydHMubWVtb3J5LmJ1ZmZlcik7XHJcblxyXG4gICAgICAgIC8vIEFsbW9zdCBkb25lIC0tIG5vdyBydW4gV0FTSSdzIGBfc3RhcnRgIG9yIGBfaW5pdGlhbGl6ZWAgZnVuY3Rpb24uXHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQoKFwiX2luaXRpYWxpemVcIiBpbiB3YXNtLmluc3RhbmNlLmV4cG9ydHMpICE9IChcIl9zdGFydFwiIGluIHdhc20uaW5zdGFuY2UuZXhwb3J0cyksIGBFeHBlY3RlZCBlaXRoZXIgX2luaXRpYWxpemUgWE9SIF9zdGFydCB0byBiZSBleHBvcnRlZCBmcm9tIHRoaXMgV0FTTS5gKTtcclxuICAgICAgICAod2FzbS5leHBvcnRzLl9pbml0aWFsaXplID8/IHdhc20uZXhwb3J0cy5fc3RhcnQpPy4oKTtcclxuXHJcbiAgICAgICAgLy8gV2FpdCBmb3IgYWxsIEVtYmluZCBjYWxscyB0byByZXNvbHZlICh0aGV5IGBhd2FpdGAgZWFjaCBvdGhlciBiYXNlZCBvbiB0aGUgZGVwZW5kZW5jaWVzIHRoZXkgbmVlZCwgYW5kIHRoaXMgcmVzb2x2ZXMgd2hlbiBhbGwgZGVwZW5kZW5jaWVzIGhhdmUgdG9vKVxyXG4gICAgICAgIGF3YWl0IGF3YWl0QWxsRW1iaW5kKCk7XHJcblxyXG4gICAgICAgIC8vIEFuZCB3ZSdyZSBmaW5hbGx5IGZpbmlzaGVkLlxyXG4gICAgICAgIHJldHVybiB3YXNtO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyBHaXZlbiBhbiBvYmplY3QsIGJpbmRzIGVhY2ggZnVuY3Rpb24gaW4gdGhhdCBvYmplY3QgdG8gcCAoc2hhbGxvd2x5KS5cclxuZnVuY3Rpb24gYmluZEFsbEZ1bmNzPFIgZXh0ZW5kcyBvYmplY3Q+KHA6IEluc3RhbnRpYXRlZFdhc20sIHI6IFIpOiBSIHtcclxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMocikubWFwKChba2V5LCBmdW5jXSkgPT4geyByZXR1cm4gW2tleSwgKHR5cGVvZiBmdW5jID09IFwiZnVuY3Rpb25cIiA/IChmdW5jIGFzICguLi5hcmdzOiB1bmtub3duW10pID0+IHVua25vd24pLmJpbmQocCkgOiBmdW5jKV0gYXMgY29uc3Q7IH0pKSBhcyBSO1xyXG59XHJcblxyXG4vLyBTZXBhcmF0ZWQgb3V0IGZvciB0eXBlIHJlYXNvbnMgZHVlIHRvIFwiUmVzcG9uc2VcIiBub3QgZXhpc3RpbmcgaW4gbGltaXRlZCBXb3JrbGV0LWxpa2UgZW52aXJvbm1lbnRzLlxyXG5mdW5jdGlvbiBpc1Jlc3BvbnNlKGFyZzogb2JqZWN0KTogYXJnIGlzIFJlc3BvbnNlIHwgUHJvbWlzZUxpa2U8UmVzcG9uc2U+IHsgcmV0dXJuIFwidGhlblwiIGluIGFyZyB8fCAoXCJSZXNwb25zZVwiIGluIGdsb2JhbFRoaXMgJiYgYXJnIGluc3RhbmNlb2YgUmVzcG9uc2UpOyB9XHJcblxyXG4iXX0=